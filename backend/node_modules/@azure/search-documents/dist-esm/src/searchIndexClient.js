// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from "tslib";
/// <reference lib="esnext.asynciterable" />
import { isTokenCredential } from "@azure/core-auth";
import { createPipelineFromOptions, operationOptionsToRequestOptionsBase, bearerTokenAuthenticationPolicy } from "@azure/core-http";
import { SpanStatusCode } from "@azure/core-tracing";
import { SDK_VERSION } from "./constants";
import { SearchServiceClient as GeneratedClient } from "./generated/service/searchServiceClient";
import { logger } from "./logger";
import { createSearchApiKeyCredentialPolicy } from "./searchApiKeyCredentialPolicy";
import * as utils from "./serviceUtils";
import { createSpan } from "./tracing";
import { odataMetadataPolicy } from "./odataMetadataPolicy";
import { SearchClient } from "./searchClient";
import { KnownSearchAudience } from "./searchAudience";
/**
 * Class to perform operations to manage
 * (create, update, list/delete)
 * indexes, & synonymmaps.
 */
export class SearchIndexClient {
    /**
     * Creates an instance of SearchIndexClient.
     *
     * Example usage:
     * ```ts
     * const { SearchIndexClient, AzureKeyCredential } = require("@azure/search-documents");
     *
     * const client = new SearchIndexClient(
     *   "<endpoint>",
     *   new AzureKeyCredential("<Admin Key>");
     * );
     * ```
     * @param endpoint - The endpoint of the search service
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Search Index client.
     */
    constructor(endpoint, credential, options = {}) {
        /**
         * The API version to use when communicating with the service.
         */
        this.apiVersion = "2020-06-30";
        this.endpoint = endpoint;
        this.credential = credential;
        this.options = options;
        const libInfo = `azsdk-js-search-documents/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        if (options.userAgentOptions.userAgentPrefix) {
            options.userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            options.userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: [
                    "elapsed-time",
                    "Location",
                    "OData-MaxVersion",
                    "OData-Version",
                    "Prefer",
                    "throttle-reason"
                ]
            }
        });
        const scope = options.audience
            ? `${options.audience}/.default`
            : `${KnownSearchAudience.AzurePublicCloud}/.default`;
        const requestPolicyFactory = isTokenCredential(credential)
            ? bearerTokenAuthenticationPolicy(credential, scope)
            : createSearchApiKeyCredentialPolicy(credential);
        const pipeline = createPipelineFromOptions(internalPipelineOptions, requestPolicyFactory);
        if (Array.isArray(pipeline.requestPolicyFactories)) {
            pipeline.requestPolicyFactories.unshift(odataMetadataPolicy("minimal"));
        }
        let apiVersion = this.apiVersion;
        if (options.apiVersion) {
            if (!["2020-06-30-Preview", "2020-06-30"].includes(options.apiVersion)) {
                throw new Error(`Invalid Api Version: ${options.apiVersion}`);
            }
            apiVersion = options.apiVersion;
        }
        this.client = new GeneratedClient(this.endpoint, apiVersion, pipeline);
    }
    listIndexesPage(options = {}) {
        return __asyncGenerator(this, arguments, function* listIndexesPage_1() {
            const { span, updatedOptions } = createSpan("SearchIndexClient-listIndexesPage", options);
            try {
                const result = yield __await(this.client.indexes.list(operationOptionsToRequestOptionsBase(updatedOptions)));
                const mapped = result.indexes.map(utils.generatedIndexToPublicIndex);
                yield yield __await(mapped);
            }
            catch (e) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listIndexesAll(options = {}) {
        return __asyncGenerator(this, arguments, function* listIndexesAll_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.listIndexesPage(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves a list of existing indexes in the service.
     * @param options - Options to the list index operation.
     */
    listIndexes(options = {}) {
        const iter = this.listIndexesAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listIndexesPage(options);
            }
        };
    }
    listIndexesNamesPage(options = {}) {
        return __asyncGenerator(this, arguments, function* listIndexesNamesPage_1() {
            const { span, updatedOptions } = createSpan("SearchIndexClient-listIndexesNamesPage", options);
            try {
                const result = yield __await(this.client.indexes.list(Object.assign(Object.assign({}, operationOptionsToRequestOptionsBase(updatedOptions)), { select: "name" })));
                const mapped = result.indexes.map((idx) => idx.name);
                yield yield __await(mapped);
            }
            catch (e) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listIndexesNamesAll(options = {}) {
        return __asyncGenerator(this, arguments, function* listIndexesNamesAll_1() {
            var e_2, _a;
            try {
                for (var _b = __asyncValues(this.listIndexesNamesPage(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves a list of names of existing indexes in the service.
     * @param options - Options to the list index operation.
     */
    listIndexesNames(options = {}) {
        const iter = this.listIndexesNamesAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listIndexesNamesPage(options);
            }
        };
    }
    /**
     * Retrieves a list of existing SynonymMaps in the service.
     * @param options - Options to the list SynonymMaps operation.
     */
    async listSynonymMaps(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-listSynonymMaps", options);
        try {
            const result = await this.client.synonymMaps.list(operationOptionsToRequestOptionsBase(updatedOptions));
            return result.synonymMaps.map(utils.generatedSynonymMapToPublicSynonymMap);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of names of existing SynonymMaps in the service.
     * @param options - Options to the list SynonymMaps operation.
     */
    async listSynonymMapsNames(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-listSynonymMapsNames", options);
        try {
            const result = await this.client.synonymMaps.list(Object.assign(Object.assign({}, operationOptionsToRequestOptionsBase(updatedOptions)), { select: "name" }));
            return result.synonymMaps.map((sm) => sm.name);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves information about an index.
     * @param indexName - The name of the index.
     * @param options - Additional optional arguments.
     */
    async getIndex(indexName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-getIndex", options);
        try {
            const result = await this.client.indexes.get(indexName, operationOptionsToRequestOptionsBase(updatedOptions));
            return utils.generatedIndexToPublicIndex(result);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves information about a SynonymMap.
     * @param synonymMapName - The name of the SynonymMap.
     * @param options - Additional optional arguments.
     */
    async getSynonymMap(synonymMapName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-getSynonymMaps", options);
        try {
            const result = await this.client.synonymMaps.get(synonymMapName, operationOptionsToRequestOptionsBase(updatedOptions));
            return utils.generatedSynonymMapToPublicSynonymMap(result);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new index.
     * @param index - The information describing the index to be created.
     * @param options - Additional optional arguments.
     */
    async createIndex(index, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-createIndex", options);
        try {
            const result = await this.client.indexes.create(utils.publicIndexToGeneratedIndex(index), operationOptionsToRequestOptionsBase(updatedOptions));
            return utils.generatedIndexToPublicIndex(result);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new SynonymMap in a search service.
     * @param synonymMap - The synonymMap definition to create in a search service.
     * @param options - Additional optional arguments.
     */
    async createSynonymMap(synonymMap, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-createSynonymMaps", options);
        try {
            const result = await this.client.synonymMaps.create(utils.publicSynonymMapToGeneratedSynonymMap(synonymMap), operationOptionsToRequestOptionsBase(updatedOptions));
            return utils.generatedSynonymMapToPublicSynonymMap(result);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new index or modifies an existing one.
     * @param index - The information describing the index to be created.
     * @param options - Additional optional arguments.
     */
    async createOrUpdateIndex(index, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-createOrUpdateIndex", options);
        try {
            const etag = options.onlyIfUnchanged ? index.etag : undefined;
            const result = await this.client.indexes.createOrUpdate(index.name, utils.publicIndexToGeneratedIndex(index), Object.assign(Object.assign({}, operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
            return utils.generatedIndexToPublicIndex(result);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new SynonymMap or modifies an existing one.
     * @param synonymMap - The information describing the SynonymMap to be created.
     * @param options - Additional optional arguments.
     */
    async createOrUpdateSynonymMap(synonymMap, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-createOrUpdateSynonymMap", options);
        try {
            const etag = options.onlyIfUnchanged ? synonymMap.etag : undefined;
            const result = await this.client.synonymMaps.createOrUpdate(synonymMap.name, utils.publicSynonymMapToGeneratedSynonymMap(synonymMap), Object.assign(Object.assign({}, operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
            return utils.generatedSynonymMapToPublicSynonymMap(result);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes an existing index.
     * @param indexName - Index/Name of the index to delete.
     * @param options - Additional optional arguments.
     */
    async deleteIndex(index, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-deleteIndex", options);
        try {
            const indexName = typeof index === "string" ? index : index.name;
            const etag = typeof index === "string" ? undefined : options.onlyIfUnchanged ? index.etag : undefined;
            await this.client.indexes.delete(indexName, Object.assign(Object.assign({}, operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes an existing SynonymMap.
     * @param synonymMapName - SynonymMap/Name of the synonymMap to delete.
     * @param options - Additional optional arguments.
     */
    async deleteSynonymMap(synonymMap, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-deleteSynonymMap", options);
        try {
            const synonymMapName = typeof synonymMap === "string" ? synonymMap : synonymMap.name;
            const etag = typeof synonymMap === "string"
                ? undefined
                : options.onlyIfUnchanged
                    ? synonymMap.etag
                    : undefined;
            await this.client.synonymMaps.delete(synonymMapName, Object.assign(Object.assign({}, operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves statistics about an index, such as the count of documents and the size
     * of index storage.
     * @param indexName - The name of the index.
     * @param options - Additional optional arguments.
     */
    async getIndexStatistics(indexName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-getIndexStatistics", options);
        try {
            const result = await this.client.indexes.getStatistics(indexName, operationOptionsToRequestOptionsBase(updatedOptions));
            return result;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Calls an analyzer or tokenizer manually on provided text.
     * @param indexName - The name of the index that contains the field to analyze
     * @param text - The text to break into tokens.
     * @param options - Additional arguments
     */
    async analyzeText(indexName, options) {
        const { operationOptions, restOptions } = utils.extractOperationOptions(options);
        const { span, updatedOptions } = createSpan("SearchIndexClient-analyzeText", operationOptions);
        try {
            const result = await this.client.indexes.analyze(indexName, Object.assign(Object.assign({}, restOptions), { analyzer: restOptions.analyzerName, tokenizer: restOptions.tokenizerName }), operationOptionsToRequestOptionsBase(updatedOptions));
            return result;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves statistics about the service, such as the count of documents, index, etc.
     * @param options - Additional optional arguments.
     */
    async getServiceStatistics(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-getServiceStatistics", options);
        try {
            const result = await this.client.getServiceStatistics(operationOptionsToRequestOptionsBase(updatedOptions));
            return result;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves the SearchClient corresponding to this SearchIndexClient
     * @param indexName - Name of the index
     * @param options - SearchClient Options
     */
    getSearchClient(indexName, options) {
        return new SearchClient(this.endpoint, indexName, this.credential, options || this.options);
    }
}
//# sourceMappingURL=searchIndexClient.js.map