'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var coreAuth = require('@azure/core-auth');
var logger$1 = require('@azure/logger');
var coreTracing = require('@azure/core-tracing');
var EventEmitter = _interopDefault(require('events'));
var util = require('util');
var fs = require('fs');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const SearchError = {
    type: {
        name: "Composite",
        className: "SearchError",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchError"
                        }
                    }
                }
            }
        }
    }
};
const SearchDocumentsResult = {
    type: {
        name: "Composite",
        className: "SearchDocumentsResult",
        modelProperties: {
            count: {
                serializedName: "@odata\\.count",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            coverage: {
                serializedName: "@search\\.coverage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            facets: {
                serializedName: "@search\\.facets",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Sequence",
                            element: { type: { name: "Composite", className: "FacetResult" } }
                        }
                    }
                }
            },
            nextPageParameters: {
                serializedName: "@search\\.nextPageParameters",
                type: {
                    name: "Composite",
                    className: "SearchRequest"
                }
            },
            results: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@odata\\.nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FacetResult = {
    type: {
        name: "Composite",
        className: "FacetResult",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            count: {
                serializedName: "count",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SearchRequest = {
    type: {
        name: "Composite",
        className: "SearchRequest",
        modelProperties: {
            includeTotalResultCount: {
                serializedName: "count",
                type: {
                    name: "Boolean"
                }
            },
            facets: {
                serializedName: "facets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            highlightFields: {
                serializedName: "highlight",
                type: {
                    name: "String"
                }
            },
            highlightPostTag: {
                serializedName: "highlightPostTag",
                type: {
                    name: "String"
                }
            },
            highlightPreTag: {
                serializedName: "highlightPreTag",
                type: {
                    name: "String"
                }
            },
            minimumCoverage: {
                serializedName: "minimumCoverage",
                type: {
                    name: "Number"
                }
            },
            orderBy: {
                serializedName: "orderby",
                type: {
                    name: "String"
                }
            },
            queryType: {
                serializedName: "queryType",
                type: {
                    name: "Enum",
                    allowedValues: ["simple", "full"]
                }
            },
            scoringStatistics: {
                serializedName: "scoringStatistics",
                type: {
                    name: "Enum",
                    allowedValues: ["local", "global"]
                }
            },
            sessionId: {
                serializedName: "sessionId",
                type: {
                    name: "String"
                }
            },
            scoringParameters: {
                serializedName: "scoringParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            scoringProfile: {
                serializedName: "scoringProfile",
                type: {
                    name: "String"
                }
            },
            searchText: {
                serializedName: "search",
                type: {
                    name: "String"
                }
            },
            searchFields: {
                serializedName: "searchFields",
                type: {
                    name: "String"
                }
            },
            searchMode: {
                serializedName: "searchMode",
                type: {
                    name: "Enum",
                    allowedValues: ["any", "all"]
                }
            },
            select: {
                serializedName: "select",
                type: {
                    name: "String"
                }
            },
            skip: {
                serializedName: "skip",
                type: {
                    name: "Number"
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SearchResult = {
    type: {
        name: "Composite",
        className: "SearchResult",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            _score: {
                serializedName: "@search\\.score",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            _highlights: {
                serializedName: "@search\\.highlights",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Sequence", element: { type: { name: "String" } } }
                    }
                }
            }
        }
    }
};
const SuggestDocumentsResult = {
    type: {
        name: "Composite",
        className: "SuggestDocumentsResult",
        modelProperties: {
            results: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SuggestResult"
                        }
                    }
                }
            },
            coverage: {
                serializedName: "@search\\.coverage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SuggestResult = {
    type: {
        name: "Composite",
        className: "SuggestResult",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            _text: {
                serializedName: "@search\\.text",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SuggestRequest = {
    type: {
        name: "Composite",
        className: "SuggestRequest",
        modelProperties: {
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            useFuzzyMatching: {
                serializedName: "fuzzy",
                type: {
                    name: "Boolean"
                }
            },
            highlightPostTag: {
                serializedName: "highlightPostTag",
                type: {
                    name: "String"
                }
            },
            highlightPreTag: {
                serializedName: "highlightPreTag",
                type: {
                    name: "String"
                }
            },
            minimumCoverage: {
                serializedName: "minimumCoverage",
                type: {
                    name: "Number"
                }
            },
            orderBy: {
                serializedName: "orderby",
                type: {
                    name: "String"
                }
            },
            searchText: {
                serializedName: "search",
                required: true,
                type: {
                    name: "String"
                }
            },
            searchFields: {
                serializedName: "searchFields",
                type: {
                    name: "String"
                }
            },
            select: {
                serializedName: "select",
                type: {
                    name: "String"
                }
            },
            suggesterName: {
                serializedName: "suggesterName",
                required: true,
                type: {
                    name: "String"
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const IndexBatch = {
    type: {
        name: "Composite",
        className: "IndexBatch",
        modelProperties: {
            actions: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IndexAction"
                        }
                    }
                }
            }
        }
    }
};
const IndexAction = {
    type: {
        name: "Composite",
        className: "IndexAction",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            __actionType: {
                serializedName: "@search\\.action",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["upload", "merge", "mergeOrUpload", "delete"]
                }
            }
        }
    }
};
const IndexDocumentsResult = {
    type: {
        name: "Composite",
        className: "IndexDocumentsResult",
        modelProperties: {
            results: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IndexingResult"
                        }
                    }
                }
            }
        }
    }
};
const IndexingResult = {
    type: {
        name: "Composite",
        className: "IndexingResult",
        modelProperties: {
            key: {
                serializedName: "key",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            succeeded: {
                serializedName: "status",
                required: true,
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutocompleteResult = {
    type: {
        name: "Composite",
        className: "AutocompleteResult",
        modelProperties: {
            coverage: {
                serializedName: "@search\\.coverage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            results: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutocompleteItem"
                        }
                    }
                }
            }
        }
    }
};
const AutocompleteItem = {
    type: {
        name: "Composite",
        className: "AutocompleteItem",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            queryPlusText: {
                serializedName: "queryPlusText",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutocompleteRequest = {
    type: {
        name: "Composite",
        className: "AutocompleteRequest",
        modelProperties: {
            searchText: {
                serializedName: "search",
                required: true,
                type: {
                    name: "String"
                }
            },
            autocompleteMode: {
                serializedName: "autocompleteMode",
                type: {
                    name: "Enum",
                    allowedValues: ["oneTerm", "twoTerms", "oneTermWithContext"]
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            useFuzzyMatching: {
                serializedName: "fuzzy",
                type: {
                    name: "Boolean"
                }
            },
            highlightPostTag: {
                serializedName: "highlightPostTag",
                type: {
                    name: "String"
                }
            },
            highlightPreTag: {
                serializedName: "highlightPreTag",
                type: {
                    name: "String"
                }
            },
            minimumCoverage: {
                serializedName: "minimumCoverage",
                type: {
                    name: "Number"
                }
            },
            searchFields: {
                serializedName: "searchFields",
                type: {
                    name: "String"
                }
            },
            suggesterName: {
                serializedName: "suggesterName",
                required: true,
                type: {
                    name: "String"
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SearchError: SearchError,
    SearchDocumentsResult: SearchDocumentsResult,
    FacetResult: FacetResult,
    SearchRequest: SearchRequest,
    SearchResult: SearchResult,
    SuggestDocumentsResult: SuggestDocumentsResult,
    SuggestResult: SuggestResult,
    SuggestRequest: SuggestRequest,
    IndexBatch: IndexBatch,
    IndexAction: IndexAction,
    IndexDocumentsResult: IndexDocumentsResult,
    IndexingResult: IndexingResult,
    AutocompleteResult: AutocompleteResult,
    AutocompleteItem: AutocompleteItem,
    AutocompleteRequest: AutocompleteRequest
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const indexName = {
    parameterPath: "indexName",
    mapper: {
        serializedName: "indexName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const xMsClientRequestId = {
    parameterPath: ["options", "requestOptionsParam", "xMsClientRequestId"],
    mapper: {
        serializedName: "x-ms-client-request-id",
        type: {
            name: "Uuid"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const searchText = {
    parameterPath: ["options", "searchText"],
    mapper: {
        serializedName: "search",
        type: {
            name: "String"
        }
    }
};
const includeTotalResultCount = {
    parameterPath: ["options", "searchOptions", "includeTotalResultCount"],
    mapper: {
        serializedName: "$count",
        type: {
            name: "Boolean"
        }
    }
};
const facets = {
    parameterPath: ["options", "searchOptions", "facets"],
    mapper: {
        serializedName: "facet",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Multi
};
const filter = {
    parameterPath: ["options", "searchOptions", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const highlightFields = {
    parameterPath: ["options", "searchOptions", "highlightFields"],
    mapper: {
        serializedName: "highlight",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const highlightPostTag = {
    parameterPath: ["options", "searchOptions", "highlightPostTag"],
    mapper: {
        serializedName: "highlightPostTag",
        type: {
            name: "String"
        }
    }
};
const highlightPreTag = {
    parameterPath: ["options", "searchOptions", "highlightPreTag"],
    mapper: {
        serializedName: "highlightPreTag",
        type: {
            name: "String"
        }
    }
};
const minimumCoverage = {
    parameterPath: ["options", "searchOptions", "minimumCoverage"],
    mapper: {
        serializedName: "minimumCoverage",
        type: {
            name: "Number"
        }
    }
};
const orderBy = {
    parameterPath: ["options", "searchOptions", "orderBy"],
    mapper: {
        serializedName: "$orderby",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const queryType = {
    parameterPath: ["options", "searchOptions", "queryType"],
    mapper: {
        serializedName: "queryType",
        type: {
            name: "Enum",
            allowedValues: ["simple", "full"]
        }
    }
};
const scoringParameters = {
    parameterPath: ["options", "searchOptions", "scoringParameters"],
    mapper: {
        serializedName: "scoringParameter",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Multi
};
const scoringProfile = {
    parameterPath: ["options", "searchOptions", "scoringProfile"],
    mapper: {
        serializedName: "scoringProfile",
        type: {
            name: "String"
        }
    }
};
const searchFields = {
    parameterPath: ["options", "searchOptions", "searchFields"],
    mapper: {
        serializedName: "searchFields",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const searchMode = {
    parameterPath: ["options", "searchOptions", "searchMode"],
    mapper: {
        serializedName: "searchMode",
        type: {
            name: "Enum",
            allowedValues: ["any", "all"]
        }
    }
};
const scoringStatistics = {
    parameterPath: ["options", "searchOptions", "scoringStatistics"],
    mapper: {
        serializedName: "scoringStatistics",
        type: {
            name: "Enum",
            allowedValues: ["local", "global"]
        }
    }
};
const sessionId = {
    parameterPath: ["options", "searchOptions", "sessionId"],
    mapper: {
        serializedName: "sessionId",
        type: {
            name: "String"
        }
    }
};
const select = {
    parameterPath: ["options", "searchOptions", "select"],
    mapper: {
        serializedName: "$select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const skip = {
    parameterPath: ["options", "searchOptions", "skip"],
    mapper: {
        serializedName: "$skip",
        type: {
            name: "Number"
        }
    }
};
const top = {
    parameterPath: ["options", "searchOptions", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const searchRequest = {
    parameterPath: "searchRequest",
    mapper: SearchRequest
};
const key = {
    parameterPath: "key",
    mapper: {
        serializedName: "key",
        required: true,
        type: {
            name: "String"
        }
    }
};
const selectedFields = {
    parameterPath: ["options", "selectedFields"],
    mapper: {
        serializedName: "$select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const searchText1 = {
    parameterPath: "searchText",
    mapper: {
        serializedName: "search",
        required: true,
        type: {
            name: "String"
        }
    }
};
const suggesterName = {
    parameterPath: "suggesterName",
    mapper: {
        serializedName: "suggesterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const filter1 = {
    parameterPath: ["options", "suggestOptions", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const useFuzzyMatching = {
    parameterPath: ["options", "suggestOptions", "useFuzzyMatching"],
    mapper: {
        serializedName: "fuzzy",
        type: {
            name: "Boolean"
        }
    }
};
const highlightPostTag1 = {
    parameterPath: ["options", "suggestOptions", "highlightPostTag"],
    mapper: {
        serializedName: "highlightPostTag",
        type: {
            name: "String"
        }
    }
};
const highlightPreTag1 = {
    parameterPath: ["options", "suggestOptions", "highlightPreTag"],
    mapper: {
        serializedName: "highlightPreTag",
        type: {
            name: "String"
        }
    }
};
const minimumCoverage1 = {
    parameterPath: ["options", "suggestOptions", "minimumCoverage"],
    mapper: {
        serializedName: "minimumCoverage",
        type: {
            name: "Number"
        }
    }
};
const orderBy1 = {
    parameterPath: ["options", "suggestOptions", "orderBy"],
    mapper: {
        serializedName: "$orderby",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const searchFields1 = {
    parameterPath: ["options", "suggestOptions", "searchFields"],
    mapper: {
        serializedName: "searchFields",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const select1 = {
    parameterPath: ["options", "suggestOptions", "select"],
    mapper: {
        serializedName: "$select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const top1 = {
    parameterPath: ["options", "suggestOptions", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const suggestRequest = {
    parameterPath: "suggestRequest",
    mapper: SuggestRequest
};
const batch = {
    parameterPath: "batch",
    mapper: IndexBatch
};
const autocompleteMode = {
    parameterPath: ["options", "autocompleteOptions", "autocompleteMode"],
    mapper: {
        serializedName: "autocompleteMode",
        type: {
            name: "Enum",
            allowedValues: ["oneTerm", "twoTerms", "oneTermWithContext"]
        }
    }
};
const filter2 = {
    parameterPath: ["options", "autocompleteOptions", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const useFuzzyMatching1 = {
    parameterPath: ["options", "autocompleteOptions", "useFuzzyMatching"],
    mapper: {
        serializedName: "fuzzy",
        type: {
            name: "Boolean"
        }
    }
};
const highlightPostTag2 = {
    parameterPath: ["options", "autocompleteOptions", "highlightPostTag"],
    mapper: {
        serializedName: "highlightPostTag",
        type: {
            name: "String"
        }
    }
};
const highlightPreTag2 = {
    parameterPath: ["options", "autocompleteOptions", "highlightPreTag"],
    mapper: {
        serializedName: "highlightPreTag",
        type: {
            name: "String"
        }
    }
};
const minimumCoverage2 = {
    parameterPath: ["options", "autocompleteOptions", "minimumCoverage"],
    mapper: {
        serializedName: "minimumCoverage",
        type: {
            name: "Number"
        }
    }
};
const searchFields2 = {
    parameterPath: ["options", "autocompleteOptions", "searchFields"],
    mapper: {
        serializedName: "searchFields",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const top2 = {
    parameterPath: ["options", "autocompleteOptions", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const autocompleteRequest = {
    parameterPath: "autocompleteRequest",
    mapper: AutocompleteRequest
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a Documents. */
class Documents {
    /**
     * Initialize a new instance of the class Documents class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Queries the number of documents in the index.
     * @param options The options parameters.
     */
    count(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, countOperationSpec);
    }
    /**
     * Searches for documents in the index.
     * @param options The options parameters.
     */
    searchGet(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, searchGetOperationSpec);
    }
    /**
     * Searches for documents in the index.
     * @param searchRequest The definition of the Search request.
     * @param options The options parameters.
     */
    searchPost(searchRequest, options) {
        const operationArguments = {
            searchRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, searchPostOperationSpec);
    }
    /**
     * Retrieves a document from the index.
     * @param key The key of the document to retrieve.
     * @param options The options parameters.
     */
    get(key, options) {
        const operationArguments = {
            key,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getOperationSpec);
    }
    /**
     * Suggests documents in the index that match the given partial query text.
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no
     *                   more than 100 characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     *                      of the index definition.
     * @param options The options parameters.
     */
    suggestGet(searchText, suggesterName, options) {
        const operationArguments = {
            searchText,
            suggesterName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, suggestGetOperationSpec);
    }
    /**
     * Suggests documents in the index that match the given partial query text.
     * @param suggestRequest The Suggest request.
     * @param options The options parameters.
     */
    suggestPost(suggestRequest, options) {
        const operationArguments = {
            suggestRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, suggestPostOperationSpec);
    }
    /**
     * Sends a batch of document write actions to the index.
     * @param batch The batch of index actions.
     * @param options The options parameters.
     */
    index(batch, options) {
        const operationArguments = {
            batch,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, indexOperationSpec);
    }
    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     *                      of the index definition.
     * @param options The options parameters.
     */
    autocompleteGet(searchText, suggesterName, options) {
        const operationArguments = {
            searchText,
            suggesterName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, autocompleteGetOperationSpec);
    }
    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * @param autocompleteRequest The definition of the Autocomplete request.
     * @param options The options parameters.
     */
    autocompletePost(autocompleteRequest, options) {
        const operationArguments = {
            autocompleteRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, autocompletePostOperationSpec);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
const countOperationSpec = {
    path: "/docs/$count",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "Number" } }
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexName],
    headerParameters: [accept, xMsClientRequestId],
    serializer
};
const searchGetOperationSpec = {
    path: "/docs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchDocumentsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [
        apiVersion,
        searchText,
        includeTotalResultCount,
        facets,
        filter,
        highlightFields,
        highlightPostTag,
        highlightPreTag,
        minimumCoverage,
        orderBy,
        queryType,
        scoringParameters,
        scoringProfile,
        searchFields,
        searchMode,
        scoringStatistics,
        sessionId,
        select,
        skip,
        top
    ],
    urlParameters: [endpoint, indexName],
    headerParameters: [accept, xMsClientRequestId],
    serializer
};
const searchPostOperationSpec = {
    path: "/docs/search.post.search",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SearchDocumentsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: searchRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexName],
    headerParameters: [
        accept,
        xMsClientRequestId,
        contentType
    ],
    mediaType: "json",
    serializer
};
const getOperationSpec = {
    path: "/docs('{key}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "any" } }
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion, selectedFields],
    urlParameters: [endpoint, indexName, key],
    headerParameters: [accept, xMsClientRequestId],
    serializer
};
const suggestGetOperationSpec = {
    path: "/docs/search.suggest",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SuggestDocumentsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [
        apiVersion,
        searchText1,
        suggesterName,
        filter1,
        useFuzzyMatching,
        highlightPostTag1,
        highlightPreTag1,
        minimumCoverage1,
        orderBy1,
        searchFields1,
        select1,
        top1
    ],
    urlParameters: [endpoint, indexName],
    headerParameters: [accept, xMsClientRequestId],
    serializer
};
const suggestPostOperationSpec = {
    path: "/docs/search.post.suggest",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SuggestDocumentsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: suggestRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexName],
    headerParameters: [
        accept,
        xMsClientRequestId,
        contentType
    ],
    mediaType: "json",
    serializer
};
const indexOperationSpec = {
    path: "/docs/search.index",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IndexDocumentsResult
        },
        207: {
            bodyMapper: IndexDocumentsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: batch,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexName],
    headerParameters: [
        accept,
        xMsClientRequestId,
        contentType
    ],
    mediaType: "json",
    serializer
};
const autocompleteGetOperationSpec = {
    path: "/docs/search.autocomplete",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutocompleteResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [
        apiVersion,
        searchText1,
        suggesterName,
        autocompleteMode,
        filter2,
        useFuzzyMatching1,
        highlightPostTag2,
        highlightPreTag2,
        minimumCoverage2,
        searchFields2,
        top2
    ],
    urlParameters: [endpoint, indexName],
    headerParameters: [accept, xMsClientRequestId],
    serializer
};
const autocompletePostOperationSpec = {
    path: "/docs/search.post.autocomplete",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AutocompleteResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: autocompleteRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexName],
    headerParameters: [
        accept,
        xMsClientRequestId,
        contentType
    ],
    mediaType: "json",
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const packageName = "@azure/search-documents";
const packageVersion = "11.3.1";
/** @internal */
class SearchClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the SearchClientContext class.
     * @param endpoint The endpoint URL of the search service.
     * @param indexName The name of the index.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(endpoint, indexName, apiVersion, options) {
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        if (indexName === undefined) {
            throw new Error("'indexName' cannot be null");
        }
        if (apiVersion === undefined) {
            throw new Error("'apiVersion' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri = options.endpoint || "{endpoint}/indexes('{indexName}')";
        // Parameter assignments
        this.endpoint = endpoint;
        this.indexName = indexName;
        this.apiVersion = apiVersion;
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class SearchClient extends SearchClientContext {
    /**
     * Initializes a new instance of the SearchClient class.
     * @param endpoint The endpoint URL of the search service.
     * @param indexName The name of the index.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(endpoint, indexName, apiVersion, options) {
        super(endpoint, indexName, apiVersion, options);
        this.documents = new Documents(this);
    }
}

// Copyright (c) Microsoft Corporation.
const API_KEY_HEADER_NAME = "api-key";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Azure Cognitive Search
 */
function createSearchApiKeyCredentialPolicy(credential) {
    return {
        create: (nextPolicy, options) => {
            return new SearchApiKeyCredentialPolicy(nextPolicy, options, credential);
        }
    };
}
/**
 * A concrete implementation of an AzureKeyCredential policy
 * using the appropriate header for Azure Cognitive Search
 */
class SearchApiKeyCredentialPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options, credential) {
        super(nextPolicy, options);
        this.credential = credential;
    }
    async sendRequest(webResource) {
        if (!webResource) {
            throw new Error("webResource cannot be null or undefined");
        }
        webResource.headers.set(API_KEY_HEADER_NAME, this.credential.key);
        return this._nextPolicy.sendRequest(webResource);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "11.3.1";

// Copyright (c) Microsoft Corporation.
/**
 * The `@azure/logger` configuration for this package.
 */
const logger = logger$1.createClientLogger("search");

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @internal
 */
const createSpan = coreTracing.createSpanFunction({
    packagePrefix: "Azure.Search",
    namespace: "Microsoft.Search"
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const WorldGeodeticSystem1984 = "EPSG:4326"; // See https://epsg.io/4326
/**
 * Represents a geographic point in global coordinates.
 */
class GeographyPoint {
    /**
     * Constructs a new instance of GeographyPoint given
     * the specified coordinates.
     * @param geographyPoint - object with longitude and latitude values in decimal
     */
    constructor(geographyPoint) {
        this.longitude = geographyPoint.longitude;
        this.latitude = geographyPoint.latitude;
    }
    /**
     * Used to serialize to a GeoJSON Point.
     */
    toJSON() {
        return {
            type: "Point",
            coordinates: [this.longitude, this.latitude],
            crs: { type: "name", properties: { name: WorldGeodeticSystem1984 } }
        };
    }
}

// Copyright (c) Microsoft Corporation.
const ISO8601DateRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/i;
const GeoJSONPointTypeName = "Point";
const WorldGeodeticSystem1984$1 = "EPSG:4326"; // See https://epsg.io/4326
function serialize(obj) {
    return walk(obj, (value) => {
        const result = serializeSpecialNumbers(value);
        return result;
    });
}
function deserialize(obj) {
    return walk(obj, (value) => {
        let result = deserializeSpecialNumbers(value);
        result = deserializeDates(result);
        result = deserializeGeoPoint(result);
        return result;
    });
}
function walk(start, mapper) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    const seenMarker = new WeakMap();
    const result = { value: undefined };
    const queue = [
        { value: start, parent: result, key: "value" }
    ];
    while (queue.length) {
        const current = queue.shift();
        if (typeof current.value === "object" && current.value !== null) {
            if (seenMarker.has(current.value)) {
                continue;
            }
            else {
                seenMarker.set(current.value, true);
            }
        }
        const mapped = mapper(current.value);
        if ((current === null || current === void 0 ? void 0 : current.parent) && current.key) {
            current.parent[current.key] = mapped;
        }
        if (typeof mapped === "object" && mapped !== null) {
            for (const key of Object.keys(mapped)) {
                queue.push({
                    value: mapped[key],
                    parent: mapped,
                    key
                });
            }
        }
    }
    return result.value;
}
function serializeSpecialNumbers(input) {
    if (typeof input === "number") {
        if (isNaN(input)) {
            return "NaN";
        }
        else if (input === Infinity) {
            return "INF";
        }
        else if (input === -Infinity) {
            return "-INF";
        }
    }
    return input;
}
function deserializeSpecialNumbers(input) {
    if (typeof input === "string") {
        if (input === "NaN") {
            return NaN;
        }
        else if (input === "INF") {
            return Infinity;
        }
        else if (input === "-INF") {
            return -Infinity;
        }
    }
    return input;
}
function deserializeDates(input) {
    if (typeof input === "string") {
        if (ISO8601DateRegex.test(input)) {
            return new Date(input);
        }
    }
    return input;
}
function deserializeGeoPoint(input) {
    if (isGeoJSONPoint(input)) {
        return new GeographyPoint({ longitude: input.coordinates[0], latitude: input.coordinates[1] });
    }
    return input;
}
function isGeoJSONPoint(obj) {
    const requiredKeys = ["type", "coordinates"];
    return isValidObject(obj, {
        requiredKeys,
        propertyValidator: (key) => {
            switch (key) {
                case "type":
                    return obj.type === GeoJSONPointTypeName;
                case "coordinates":
                    return isCoordinateArray(obj.coordinates);
                case "crs":
                    return isCrs(obj.crs);
                default:
                    return false;
            }
        }
    });
}
function isCoordinateArray(maybeCoordinates) {
    if (!Array.isArray(maybeCoordinates)) {
        return false;
    }
    if (maybeCoordinates.length !== 2) {
        return false;
    }
    if (typeof maybeCoordinates[0] !== "number" || typeof maybeCoordinates[1] !== "number") {
        return false;
    }
    return true;
}
function isCrs(maybeCrs) {
    return isValidObject(maybeCrs, {
        requiredKeys: ["type", "properties"],
        propertyValidator: (key) => {
            switch (key) {
                case "type":
                    return maybeCrs.type === "name";
                case "properties":
                    return isCrsProperties(maybeCrs.properties);
                default:
                    return false;
            }
        }
    });
}
function isCrsProperties(maybeProperties) {
    return isValidObject(maybeProperties, {
        requiredKeys: ["name"],
        propertyValidator: (key) => {
            if (key === "name") {
                return maybeProperties.name === WorldGeodeticSystem1984$1;
            }
            else {
                return false;
            }
        }
    });
}
function isValidObject(obj, options = {}) {
    if (typeof obj !== "object" || obj === null) {
        return false;
    }
    const keys = Object.keys(obj);
    if (options.requiredKeys) {
        for (const requiredKey of options.requiredKeys) {
            if (!keys.includes(requiredKey)) {
                return false;
            }
        }
    }
    if (options.propertyValidator) {
        for (const key of keys) {
            if (!options.propertyValidator(key)) {
                return false;
            }
        }
    }
    return true;
}

// Copyright (c) Microsoft Corporation.
const AcceptHeaderName = "Accept";
/**
 * A policy factory for setting the Accept header to ignore odata metadata
 * @internal
 */
function odataMetadataPolicy(metadataLevel) {
    return {
        create: (nextPolicy, options) => {
            return new OdataMetadataPolicy(nextPolicy, options, { metadataLevel });
        }
    };
}
class OdataMetadataPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options, policyOptions) {
        super(nextPolicy, options);
        this.metadataLevel = policyOptions.metadataLevel;
    }
    async sendRequest(webResource) {
        webResource.headers.set(AcceptHeaderName, `application/json;odata.metadata=${this.metadataLevel}`);
        return this._nextPolicy.sendRequest(webResource);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Class used to perform batch operations
 * with multiple documents to the index.
 */
class IndexDocumentsBatch {
    constructor(actions = []) {
        this.actions = actions;
    }
    /**
     * Upload an array of documents to the index.
     * @param documents - The documents to upload.
     */
    upload(documents) {
        const batch = documents.map((doc) => {
            return Object.assign(Object.assign({}, doc), { __actionType: "upload" });
        });
        this.actions.push(...batch);
    }
    /**
     * Update a set of documents in the index.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents - The updated documents.
     */
    merge(documents) {
        const batch = documents.map((doc) => {
            return Object.assign(Object.assign({}, doc), { __actionType: "merge" });
        });
        this.actions.push(...batch);
    }
    /**
     * Update a set of documents in the index or uploads them if they don't exist.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents - The new/updated documents.
     */
    mergeOrUpload(documents) {
        const batch = documents.map((doc) => {
            return Object.assign(Object.assign({}, doc), { __actionType: "mergeOrUpload" });
        });
        this.actions.push(...batch);
    }
    delete(keyNameOrDocuments, keyValues) {
        if (keyValues) {
            const keyName = keyNameOrDocuments;
            const batch = keyValues.map((keyValue) => {
                return {
                    __actionType: "delete",
                    [keyName]: keyValue
                };
            });
            this.actions.push(...batch);
        }
        else {
            const documents = keyNameOrDocuments;
            const batch = documents.map((document) => {
                return Object.assign({ __actionType: "delete" }, document);
            });
            this.actions.push(...batch);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Encodes a string in base64 format.
 * @param value - The string to encode.
 */
function encode(value) {
    return Buffer.from(value).toString("base64");
}
/**
 * Decodes a base64 string into a regular string.
 * @param value - The base64 string to decode.
 */
function decode(value) {
    return Buffer.from(value, "base64").toString();
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isComplexField(field) {
    return field.type === "Edm.ComplexType" || field.type === "Collection(Edm.ComplexType)";
}
(function (KnownTokenizerNames) {
    /**
     * Grammar-based tokenizer that is suitable for processing most European-language documents. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicTokenizer.html
     */
    KnownTokenizerNames["Classic"] = "classic";
    /**
     * Tokenizes the input from an edge into n-grams of the given size(s). See
     * https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenizer.html
     */
    KnownTokenizerNames["EdgeNGram"] = "edgeNGram";
    /**
     * Emits the entire input as a single token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/KeywordTokenizer.html
     */
    KnownTokenizerNames["Keyword"] = "keyword_v2";
    /**
     * Divides text at non-letters. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LetterTokenizer.html
     */
    KnownTokenizerNames["Letter"] = "letter";
    /**
     * Divides text at non-letters and converts them to lower case. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseTokenizer.html
     */
    KnownTokenizerNames["Lowercase"] = "lowercase";
    /**
     * Divides text using language-specific rules.
     */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    KnownTokenizerNames["MicrosoftLanguageTokenizer"] = "microsoft_language_tokenizer";
    /**
     * Divides text using language-specific rules and reduces words to their base forms.
     */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    KnownTokenizerNames["MicrosoftLanguageStemmingTokenizer"] = "microsoft_language_stemming_tokenizer";
    /**
     * Tokenizes the input into n-grams of the given size(s). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenizer.html
     */
    KnownTokenizerNames["NGram"] = "nGram";
    /**
     * Tokenizer for path-like hierarchies. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/path/PathHierarchyTokenizer.html
     */
    KnownTokenizerNames["PathHierarchy"] = "path_hierarchy_v2";
    /**
     * Tokenizer that uses regex pattern matching to construct distinct tokens. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/pattern/PatternTokenizer.html
     */
    KnownTokenizerNames["Pattern"] = "pattern";
    /**
     * Standard Lucene analyzer; Composed of the standard tokenizer, lowercase filter and stop
     * filter. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/StandardTokenizer.html
     */
    KnownTokenizerNames["Standard"] = "standard_v2";
    /**
     * Tokenizes urls and emails as one token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizer.html
     */
    KnownTokenizerNames["UaxUrlEmail"] = "uax_url_email";
    /**
     * Divides text at whitespace. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/WhitespaceTokenizer.html
     */
    KnownTokenizerNames["Whitespace"] = "whitespace";
})(exports.KnownTokenizerNames || (exports.KnownTokenizerNames = {}));
(function (KnownTokenFilterNames) {
    /**
     * A token filter that applies the Arabic normalizer to normalize the orthography. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ar/ArabicNormalizationFilter.html
     */
    KnownTokenFilterNames["ArabicNormalization"] = "arabic_normalization";
    /**
     * Strips all characters after an apostrophe (including the apostrophe itself). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/tr/ApostropheFilter.html
     */
    KnownTokenFilterNames["Apostrophe"] = "apostrophe";
    /**
     * Converts alphabetic, numeric, and symbolic Unicode characters which are not in the first 127
     * ASCII characters (the "Basic Latin" Unicode block) into their ASCII equivalents, if such
     * equivalents exist. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html
     */
    KnownTokenFilterNames["AsciiFolding"] = "asciifolding";
    /**
     * Forms bigrams of CJK terms that are generated from StandardTokenizer. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKBigramFilter.html
     */
    KnownTokenFilterNames["CjkBigram"] = "cjk_bigram";
    /**
     * Normalizes CJK width differences. Folds fullwidth ASCII variants into the equivalent basic
     * Latin, and half-width Katakana variants into the equivalent Kana. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKWidthFilter.html
     */
    KnownTokenFilterNames["CjkWidth"] = "cjk_width";
    /**
     * Removes English possessives, and dots from acronyms. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicFilter.html
     */
    KnownTokenFilterNames["Classic"] = "classic";
    /**
     * Construct bigrams for frequently occurring terms while indexing. Single terms are still
     * indexed too, with bigrams overlaid. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/commongrams/CommonGramsFilter.html
     */
    KnownTokenFilterNames["CommonGram"] = "common_grams";
    /**
     * Generates n-grams of the given size(s) starting from the front or the back of an input token.
     * See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenFilter.html
     */
    KnownTokenFilterNames["EdgeNGram"] = "edgeNGram_v2";
    /**
     * Removes elisions. For example, "l'avion" (the plane) will be converted to "avion" (plane). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/util/ElisionFilter.html
     */
    KnownTokenFilterNames["Elision"] = "elision";
    /**
     * Normalizes German characters according to the heuristics of the German2 snowball algorithm.
     * See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/de/GermanNormalizationFilter.html
     */
    KnownTokenFilterNames["GermanNormalization"] = "german_normalization";
    /**
     * Normalizes text in Hindi to remove some differences in spelling variations. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/hi/HindiNormalizationFilter.html
     */
    KnownTokenFilterNames["HindiNormalization"] = "hindi_normalization";
    /**
     * Normalizes the Unicode representation of text in Indian languages. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/in/IndicNormalizationFilter.html
     */
    KnownTokenFilterNames["IndicNormalization"] = "indic_normalization";
    /**
     * Emits each incoming token twice, once as keyword and once as non-keyword. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/KeywordRepeatFilter.html
     */
    KnownTokenFilterNames["KeywordRepeat"] = "keyword_repeat";
    /**
     * A high-performance kstem filter for English. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/en/KStemFilter.html
     */
    KnownTokenFilterNames["KStem"] = "kstem";
    /**
     * Removes words that are too long or too short. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LengthFilter.html
     */
    KnownTokenFilterNames["Length"] = "length";
    /**
     * Limits the number of tokens while indexing. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LimitTokenCountFilter.html
     */
    KnownTokenFilterNames["Limit"] = "limit";
    /**
     * Normalizes token text to lower case. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseFilter.htm
     */
    KnownTokenFilterNames["Lowercase"] = "lowercase";
    /**
     * Generates n-grams of the given size(s). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenFilter.html
     */
    KnownTokenFilterNames["NGram"] = "nGram_v2";
    /**
     * Applies normalization for Persian. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/fa/PersianNormalizationFilter.html
     */
    KnownTokenFilterNames["PersianNormalization"] = "persian_normalization";
    /**
     * Create tokens for phonetic matches. See
     * https://lucene.apache.org/core/4_10_3/analyzers-phonetic/org/apache/lucene/analysis/phonetic/package-tree.html
     */
    KnownTokenFilterNames["Phonetic"] = "phonetic";
    /**
     * Uses the Porter stemming algorithm to transform the token stream. See
     * http://tartarus.org/~martin/PorterStemmer
     */
    KnownTokenFilterNames["PorterStem"] = "porter_stem";
    /**
     * Reverses the token string. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/reverse/ReverseStringFilter.html
     */
    KnownTokenFilterNames["Reverse"] = "reverse";
    /**
     * Normalizes use of the interchangeable Scandinavian characters. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianNormalizationFilter.html
     */
    KnownTokenFilterNames["ScandinavianNormalization"] = "scandinavian_normalization";
    /**
     * Folds Scandinavian characters -&gt;a and -&gt;o. It also discriminates against use
     * of double vowels aa, ae, ao, oe and oo, leaving just the first one. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianFoldingFilter.html
     */
    KnownTokenFilterNames["ScandinavianFoldingNormalization"] = "scandinavian_folding";
    /**
     * Creates combinations of tokens as a single token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/shingle/ShingleFilter.html
     */
    KnownTokenFilterNames["Shingle"] = "shingle";
    /**
     * A filter that stems words using a Snowball-generated stemmer. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/snowball/SnowballFilter.html
     */
    KnownTokenFilterNames["Snowball"] = "snowball";
    /**
     * Normalizes the Unicode representation of Sorani text. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ckb/SoraniNormalizationFilter.html
     */
    KnownTokenFilterNames["SoraniNormalization"] = "sorani_normalization";
    /**
     * Language specific stemming filter. See
     * https://docs.microsoft.com/rest/api/searchservice/Custom-analyzers-in-Azure-Search#TokenFilters
     */
    KnownTokenFilterNames["Stemmer"] = "stemmer";
    /**
     * Removes stop words from a token stream. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/StopFilter.html
     */
    KnownTokenFilterNames["Stopwords"] = "stopwords";
    /**
     * Trims leading and trailing whitespace from tokens. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TrimFilter.html
     */
    KnownTokenFilterNames["Trim"] = "trim";
    /**
     * Truncates the terms to a specific length. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TruncateTokenFilter.html
     */
    KnownTokenFilterNames["Truncate"] = "truncate";
    /**
     * Filters out tokens with same text as the previous token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/RemoveDuplicatesTokenFilter.html
     */
    KnownTokenFilterNames["Unique"] = "unique";
    /**
     * Normalizes token text to upper case. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/UpperCaseFilter.html
     */
    KnownTokenFilterNames["Uppercase"] = "uppercase";
    /**
     * Splits words into subwords and performs optional transformations on subword groups.
     */
    KnownTokenFilterNames["WordDelimiter"] = "word_delimiter";
})(exports.KnownTokenFilterNames || (exports.KnownTokenFilterNames = {}));
(function (KnownCharFilterNames) {
    /**
     * A character filter that attempts to strip out HTML constructs. See
     * https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.html
     */
    KnownCharFilterNames["HtmlStrip"] = "html_strip";
})(exports.KnownCharFilterNames || (exports.KnownCharFilterNames = {}));
(function (KnownAnalyzerNames) {
    /**
     * Arabic
     */
    KnownAnalyzerNames["ArMicrosoft"] = "ar.microsoft";
    /**
     * Arabic
     */
    KnownAnalyzerNames["ArLucene"] = "ar.lucene";
    /**
     * Armenian
     */
    KnownAnalyzerNames["HyLucene"] = "hy.lucene";
    /**
     * Bangla
     */
    KnownAnalyzerNames["BnMicrosoft"] = "bn.microsoft";
    /**
     * Basque
     */
    KnownAnalyzerNames["EuLucene"] = "eu.lucene";
    /**
     * Bulgarian
     */
    KnownAnalyzerNames["BgMicrosoft"] = "bg.microsoft";
    /**
     * Bulgarian
     */
    KnownAnalyzerNames["BgLucene"] = "bg.lucene";
    /**
     * Catalan
     */
    KnownAnalyzerNames["CaMicrosoft"] = "ca.microsoft";
    /**
     * Catalan
     */
    KnownAnalyzerNames["CaLucene"] = "ca.lucene";
    /**
     * Chinese Simplified
     */
    KnownAnalyzerNames["ZhHansMicrosoft"] = "zh-Hans.microsoft";
    /**
     * Chinese Simplified
     */
    KnownAnalyzerNames["ZhHansLucene"] = "zh-Hans.lucene";
    /**
     * Chinese Traditional
     */
    KnownAnalyzerNames["ZhHantMicrosoft"] = "zh-Hant.microsoft";
    /**
     * Chinese Traditional
     */
    KnownAnalyzerNames["ZhHantLucene"] = "zh-Hant.lucene";
    /**
     * Croatian
     */
    KnownAnalyzerNames["HrMicrosoft"] = "hr.microsoft";
    /**
     * Czech
     */
    KnownAnalyzerNames["CsMicrosoft"] = "cs.microsoft";
    /**
     * Czech
     */
    KnownAnalyzerNames["CsLucene"] = "cs.lucene";
    /**
     * Danish
     */
    KnownAnalyzerNames["DaMicrosoft"] = "da.microsoft";
    /**
     * Danish
     */
    KnownAnalyzerNames["DaLucene"] = "da.lucene";
    /**
     * Dutch
     */
    KnownAnalyzerNames["NlMicrosoft"] = "nl.microsoft";
    /**
     * Dutch
     */
    KnownAnalyzerNames["NlLucene"] = "nl.lucene";
    /**
     * English
     */
    KnownAnalyzerNames["EnMicrosoft"] = "en.microsoft";
    /**
     * English
     */
    KnownAnalyzerNames["EnLucene"] = "en.lucene";
    /**
     * Estonian
     */
    KnownAnalyzerNames["EtMicrosoft"] = "et.microsoft";
    /**
     * Finnish
     */
    KnownAnalyzerNames["FiMicrosoft"] = "fi.microsoft";
    /**
     * Finnish
     */
    KnownAnalyzerNames["FiLucene"] = "fi.lucene";
    /**
     * French
     */
    KnownAnalyzerNames["FrMicrosoft"] = "fr.microsoft";
    /**
     * French
     */
    KnownAnalyzerNames["FrLucene"] = "fr.lucene";
    /**
     * Galician
     */
    KnownAnalyzerNames["GlLucene"] = "gl.lucene";
    /**
     * German
     */
    KnownAnalyzerNames["DeMicrosoft"] = "de.microsoft";
    /**
     * German
     */
    KnownAnalyzerNames["DeLucene"] = "de.lucene";
    /**
     * Greek
     */
    KnownAnalyzerNames["ElMicrosoft"] = "el.microsoft";
    /**
     * Greek
     */
    KnownAnalyzerNames["ElLucene"] = "el.lucene";
    /**
     * Gujarati
     */
    KnownAnalyzerNames["GuMicrosoft"] = "gu.microsoft";
    /**
     * Hebrew
     */
    KnownAnalyzerNames["HeMicrosoft"] = "he.microsoft";
    /**
     * Hindi
     */
    KnownAnalyzerNames["HiMicrosoft"] = "hi.microsoft";
    /**
     * Hindi
     */
    KnownAnalyzerNames["HiLucene"] = "hi.lucene";
    /**
     * Hungarian
     */
    KnownAnalyzerNames["HuMicrosoft"] = "hu.microsoft";
    /**
     * Hungarian
     */
    KnownAnalyzerNames["HuLucene"] = "hu.lucene";
    /**
     * Icelandic
     */
    KnownAnalyzerNames["IsMicrosoft"] = "is.microsoft";
    /**
     * Indonesian (Bahasa)
     */
    KnownAnalyzerNames["IdMicrosoft"] = "id.microsoft";
    /**
     * Indonesian (Bahasa)
     */
    KnownAnalyzerNames["IdLucene"] = "id.lucene";
    /**
     * Irish
     */
    KnownAnalyzerNames["GaLucene"] = "ga.lucene";
    /**
     * Italian
     */
    KnownAnalyzerNames["ItMicrosoft"] = "it.microsoft";
    /**
     * Italian
     */
    KnownAnalyzerNames["ItLucene"] = "it.lucene";
    /**
     * Japanese
     */
    KnownAnalyzerNames["JaMicrosoft"] = "ja.microsoft";
    /**
     * Japanese
     */
    KnownAnalyzerNames["JaLucene"] = "ja.lucene";
    /**
     * Kannada
     */
    KnownAnalyzerNames["KnMicrosoft"] = "kn.microsoft";
    /**
     * Korean
     */
    KnownAnalyzerNames["KoMicrosoft"] = "ko.microsoft";
    /**
     * Korean
     */
    KnownAnalyzerNames["KoLucene"] = "ko.lucene";
    /**
     * Latvian
     */
    KnownAnalyzerNames["LvMicrosoft"] = "lv.microsoft";
    /**
     * Latvian
     */
    KnownAnalyzerNames["LvLucene"] = "lv.lucene";
    /**
     * Lithuanian
     */
    KnownAnalyzerNames["LtMicrosoft"] = "lt.microsoft";
    /**
     * Malayalam
     */
    KnownAnalyzerNames["MlMicrosoft"] = "ml.microsoft";
    /**
     * Malay (Latin)
     */
    KnownAnalyzerNames["MsMicrosoft"] = "ms.microsoft";
    /**
     * Marathi
     */
    KnownAnalyzerNames["MrMicrosoft"] = "mr.microsoft";
    /**
     * Norwegian
     */
    KnownAnalyzerNames["NbMicrosoft"] = "nb.microsoft";
    /**
     * Norwegian
     */
    KnownAnalyzerNames["NoLucene"] = "no.lucene";
    /**
     * Persian
     */
    KnownAnalyzerNames["FaLucene"] = "fa.lucene";
    /**
     * Polish
     */
    KnownAnalyzerNames["PlMicrosoft"] = "pl.microsoft";
    /**
     * Polish
     */
    KnownAnalyzerNames["PlLucene"] = "pl.lucene";
    /**
     * Portuguese (Brazil)
     */
    KnownAnalyzerNames["PtBRMicrosoft"] = "pt-BR.microsoft";
    /**
     * Portuguese (Brazil)
     */
    KnownAnalyzerNames["PtBRLucene"] = "pt-BR.lucene";
    /**
     * Portuguese (Portugal)
     */
    KnownAnalyzerNames["PtPTMicrosoft"] = "pt-PT.microsoft";
    /**
     * Portuguese (Portugal)
     */
    KnownAnalyzerNames["PtPTLucene"] = "pt-PT.lucene";
    /**
     * Punjabi
     */ KnownAnalyzerNames["PaMicrosoft"] = "pa.microsoft";
    /**
     * Romanian
     */
    KnownAnalyzerNames["RoMicrosoft"] = "ro.microsoft";
    /**
     * Romanian
     */
    KnownAnalyzerNames["RoLucene"] = "ro.lucene";
    /**
     * Russian
     */
    KnownAnalyzerNames["RuMicrosoft"] = "ru.microsoft";
    /**
     * Russian
     */
    KnownAnalyzerNames["RuLucene"] = "ru.lucene";
    /**
     * Serbian (Cyrillic)
     */
    KnownAnalyzerNames["SrCyrillicMicrosoft"] = "sr-cyrillic.microsoft";
    /**
     * Serbian (Latin)
     */
    KnownAnalyzerNames["SrLatinMicrosoft"] = "sr-latin.microsoft";
    /**
     * Slovak
     */
    KnownAnalyzerNames["SkMicrosoft"] = "sk.microsoft";
    /**
     * Slovenian
     */
    KnownAnalyzerNames["SlMicrosoft"] = "sl.microsoft";
    /**
     * Spanish
     */
    KnownAnalyzerNames["EsMicrosoft"] = "es.microsoft";
    /**
     * Spanish
     */
    KnownAnalyzerNames["EsLucene"] = "es.lucene";
    /**
     * Swedish
     */
    KnownAnalyzerNames["SvMicrosoft"] = "sv.microsoft";
    /**
     * Swedish
     */
    KnownAnalyzerNames["SvLucene"] = "sv.lucene";
    /**
     * Tamil
     */
    KnownAnalyzerNames["TaMicrosoft"] = "ta.microsoft";
    /**
     * Telugu
     */
    KnownAnalyzerNames["TeMicrosoft"] = "te.microsoft";
    /**
     * Thai
     */
    KnownAnalyzerNames["ThMicrosoft"] = "th.microsoft";
    /**
     * Thai
     */
    KnownAnalyzerNames["ThLucene"] = "th.lucene";
    /**
     * Turkish
     */
    KnownAnalyzerNames["TrMicrosoft"] = "tr.microsoft";
    /**
     * Turkish
     */
    KnownAnalyzerNames["TrLucene"] = "tr.lucene";
    /**
     * Ukrainian
     */
    KnownAnalyzerNames["UkMicrosoft"] = "uk.microsoft";
    /**
     * Urdu
     */
    KnownAnalyzerNames["UrMicrosoft"] = "ur.microsoft";
    /**
     * Vietnamese
     */
    KnownAnalyzerNames["ViMicrosoft"] = "vi.microsoft";
    /**
     * See: https://lucene.apache.org/core/6_6_1/core/org/apache/lucene/analysis/standard/StandardAnalyzer.html
     */
    KnownAnalyzerNames["StandardLucene"] = "standard.lucene";
    /**
     * See https://lucene.apache.org/core/6_6_1/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html
     */
    KnownAnalyzerNames["StandardAsciiFoldingLucene"] = "standardasciifolding.lucene";
    /**
     * Treats the entire content of a field as a single token. This is useful for data like zip codes, ids, and some product names.
     */
    KnownAnalyzerNames["Keyword"] = "keyword";
    /**
     * Flexibly separates text into terms via a regular expression pattern.
     */
    KnownAnalyzerNames["Pattern"] = "pattern";
    /**
     * Divides text at non-letters and converts them to lower case.
     */
    KnownAnalyzerNames["Simple"] = "simple";
    /**
     * Divides text at non-letters; Applies the lowercase and stopword token filters.
     */
    KnownAnalyzerNames["Stop"] = "stop";
    /**
     * An analyzer that uses the whitespace tokenizer.
     */
    KnownAnalyzerNames["Whitespace"] = "whitespace";
})(exports.KnownAnalyzerNames || (exports.KnownAnalyzerNames = {}));
// END manually modified generated interfaces

// Copyright (c) Microsoft Corporation.
function convertSkillsToPublic(skills) {
    if (!skills) {
        return skills;
    }
    const result = [];
    for (const skill of skills) {
        switch (skill.odatatype) {
            case "#Microsoft.Skills.Util.ConditionalSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.KeyPhraseExtractionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Vision.OcrSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Vision.ImageAnalysisSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.LanguageDetectionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Util.ShaperSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.MergeSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.EntityRecognitionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.SentimentSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.SplitSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.TranslationSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Custom.WebApiSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.CustomEntityLookupSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Util.DocumentExtractionSkill":
                result.push(skill);
                break;
        }
    }
    return result;
}
function convertCognitiveServicesAccountToGenerated(cognitiveServicesAccount) {
    if (!cognitiveServicesAccount) {
        return cognitiveServicesAccount;
    }
    return cognitiveServicesAccount;
}
function convertCognitiveServicesAccountToPublic(cognitiveServicesAccount) {
    if (!cognitiveServicesAccount) {
        return cognitiveServicesAccount;
    }
    if (cognitiveServicesAccount.odatatype === "#Microsoft.Azure.Search.DefaultCognitiveServices") {
        return cognitiveServicesAccount;
    }
    else {
        return cognitiveServicesAccount;
    }
}
function convertTokenFiltersToGenerated(tokenFilters) {
    if (!tokenFilters) {
        return tokenFilters;
    }
    const result = [];
    for (const filter of tokenFilters) {
        result.push(filter);
    }
    return result;
}
function convertAnalyzersToGenerated(analyzers) {
    if (!analyzers) {
        return analyzers;
    }
    const result = [];
    for (const analyzer of analyzers) {
        switch (analyzer.odatatype) {
            case "#Microsoft.Azure.Search.StandardAnalyzer":
            case "#Microsoft.Azure.Search.StopAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.PatternAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { flags: analyzer.flags ? analyzer.flags.join("|") : undefined }));
                break;
            case "#Microsoft.Azure.Search.CustomAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { tokenizerName: analyzer.tokenizerName }));
                break;
        }
    }
    return result;
}
function convertAnalyzersToPublic(analyzers) {
    if (!analyzers) {
        return analyzers;
    }
    const result = [];
    for (const analyzer of analyzers) {
        switch (analyzer.odatatype) {
            case "#Microsoft.Azure.Search.StandardAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.StopAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.PatternAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { flags: analyzer.flags
                        ? analyzer.flags.split("|")
                        : undefined }));
                break;
            case "#Microsoft.Azure.Search.CustomAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { tokenizerName: analyzer.tokenizerName }));
                break;
        }
    }
    return result;
}
function convertFieldsToPublic(fields) {
    if (!fields) {
        return fields;
    }
    return fields.map((field) => {
        let result;
        if (field.type === "Collection(Edm.ComplexType)" || field.type === "Edm.ComplexType") {
            return {
                name: field.name,
                type: field.type,
                fields: convertFieldsToPublic(field.fields)
            };
        }
        else {
            const analyzerName = field.analyzer;
            const searchAnalyzerName = field.searchAnalyzer;
            const indexAnalyzerName = field.indexAnalyzer;
            const synonymMapNames = field.synonymMaps;
            const { retrievable } = field, restField = tslib.__rest(field, ["retrievable"]);
            const hidden = typeof retrievable === "boolean" ? !retrievable : retrievable;
            result = Object.assign(Object.assign({}, restField), { hidden,
                analyzerName,
                searchAnalyzerName,
                indexAnalyzerName,
                synonymMapNames });
        }
        return result;
    });
}
function convertFieldsToGenerated(fields) {
    return fields.map((field) => {
        var _a, _b, _c, _d;
        if (isComplexField(field)) {
            return {
                name: field.name,
                type: field.type,
                fields: convertFieldsToGenerated(field.fields)
            };
        }
        else {
            const { hidden } = field, restField = tslib.__rest(field, ["hidden"]);
            const retrievable = typeof hidden === "boolean" ? !hidden : hidden;
            return Object.assign(Object.assign({}, restField), { retrievable, 
                // modify API defaults to use less storage for simple types
                searchable: (_a = field.searchable) !== null && _a !== void 0 ? _a : false, filterable: (_b = field.filterable) !== null && _b !== void 0 ? _b : false, facetable: (_c = field.facetable) !== null && _c !== void 0 ? _c : false, sortable: (_d = field.sortable) !== null && _d !== void 0 ? _d : false, analyzer: field.analyzerName, searchAnalyzer: field.searchAnalyzerName, indexAnalyzer: field.indexAnalyzerName, synonymMaps: field.synonymMapNames });
        }
    });
}
function convertTokenizersToGenerated(tokenizers) {
    if (!tokenizers) {
        return tokenizers;
    }
    const result = [];
    for (const tokenizer of tokenizers) {
        if (tokenizer.odatatype === "#Microsoft.Azure.Search.PatternTokenizer") {
            result.push(Object.assign(Object.assign({}, tokenizer), { flags: tokenizer.flags ? tokenizer.flags.join("|") : undefined }));
        }
        else {
            result.push(tokenizer);
        }
    }
    return result;
}
function convertTokenizersToPublic(tokenizers) {
    if (!tokenizers) {
        return tokenizers;
    }
    const result = [];
    for (const tokenizer of tokenizers) {
        if (tokenizer.odatatype === "#Microsoft.Azure.Search.PatternTokenizer") {
            result.push(Object.assign(Object.assign({}, tokenizer), { flags: tokenizer.flags
                    ? tokenizer.flags.split("|")
                    : undefined }));
        }
        else {
            result.push(tokenizer);
        }
    }
    return result;
}
function convertSimilarityToGenerated(similarity) {
    if (!similarity) {
        return similarity;
    }
    return similarity;
}
function convertSimilarityToPublic(similarity) {
    if (!similarity) {
        return similarity;
    }
    if (similarity.odatatype === "#Microsoft.Azure.Search.ClassicSimilarity") {
        return similarity;
    }
    else {
        return similarity;
    }
}
function extractOperationOptions(obj) {
    const { abortSignal, requestOptions, tracingOptions } = obj, restOptions = tslib.__rest(obj, ["abortSignal", "requestOptions", "tracingOptions"]);
    return {
        operationOptions: {
            abortSignal,
            requestOptions,
            tracingOptions
        },
        restOptions
    };
}
function convertEncryptionKeyToPublic(encryptionKey) {
    if (!encryptionKey) {
        return encryptionKey;
    }
    const result = {
        keyName: encryptionKey.keyName,
        keyVersion: encryptionKey.keyVersion,
        vaultUrl: encryptionKey.vaultUri
    };
    if (encryptionKey.accessCredentials) {
        result.applicationId = encryptionKey.accessCredentials.applicationId;
        result.applicationSecret = encryptionKey.accessCredentials.applicationSecret;
    }
    return result;
}
function convertEncryptionKeyToGenerated(encryptionKey) {
    if (!encryptionKey) {
        return encryptionKey;
    }
    const result = {
        keyName: encryptionKey.keyName,
        keyVersion: encryptionKey.keyVersion,
        vaultUri: encryptionKey.vaultUrl
    };
    if (encryptionKey.applicationId) {
        result.accessCredentials = {
            applicationId: encryptionKey.applicationId,
            applicationSecret: encryptionKey.applicationSecret
        };
    }
    return result;
}
function generatedIndexToPublicIndex(generatedIndex) {
    return {
        name: generatedIndex.name,
        defaultScoringProfile: generatedIndex.defaultScoringProfile,
        corsOptions: generatedIndex.corsOptions,
        suggesters: generatedIndex.suggesters,
        encryptionKey: convertEncryptionKeyToPublic(generatedIndex.encryptionKey),
        etag: generatedIndex.etag,
        analyzers: convertAnalyzersToPublic(generatedIndex.analyzers),
        tokenizers: convertTokenizersToPublic(generatedIndex.tokenizers),
        tokenFilters: generatedIndex.tokenFilters,
        charFilters: generatedIndex.charFilters,
        scoringProfiles: generatedIndex.scoringProfiles,
        fields: convertFieldsToPublic(generatedIndex.fields),
        similarity: convertSimilarityToPublic(generatedIndex.similarity)
    };
}
function generatedSearchResultToPublicSearchResult(results) {
    const returnValues = results.map((result) => {
        const { _score, _highlights, rerankerScore, captions } = result, restProps = tslib.__rest(result, ["_score", "_highlights", "rerankerScore", "captions"]);
        const doc = Object.assign({}, restProps);
        const obj = {
            score: _score,
            highlights: _highlights,
            document: doc
        };
        return obj;
    });
    return returnValues;
}
function generatedSuggestDocumentsResultToPublicSuggestDocumentsResult(searchDocumentsResult) {
    const results = searchDocumentsResult.results.map((element) => {
        const { _text } = element, restProps = tslib.__rest(element, ["_text"]);
        const doc = Object.assign({}, restProps);
        const obj = {
            text: _text,
            document: doc
        };
        return obj;
    });
    const result = {
        results: results,
        coverage: searchDocumentsResult.coverage
    };
    return result;
}
function publicIndexToGeneratedIndex(index) {
    return {
        name: index.name,
        defaultScoringProfile: index.defaultScoringProfile,
        corsOptions: index.corsOptions,
        suggesters: index.suggesters,
        encryptionKey: convertEncryptionKeyToGenerated(index.encryptionKey),
        etag: index.etag,
        tokenFilters: convertTokenFiltersToGenerated(index.tokenFilters),
        charFilters: index.charFilters,
        scoringProfiles: index.scoringProfiles,
        analyzers: convertAnalyzersToGenerated(index.analyzers),
        tokenizers: convertTokenizersToGenerated(index.tokenizers),
        fields: convertFieldsToGenerated(index.fields),
        similarity: convertSimilarityToGenerated(index.similarity)
    };
}
function generatedSkillsetToPublicSkillset(generatedSkillset) {
    return {
        name: generatedSkillset.name,
        description: generatedSkillset.description,
        skills: convertSkillsToPublic(generatedSkillset.skills),
        cognitiveServicesAccount: convertCognitiveServicesAccountToPublic(generatedSkillset.cognitiveServicesAccount),
        knowledgeStore: generatedSkillset.knowledgeStore,
        etag: generatedSkillset.etag,
        encryptionKey: convertEncryptionKeyToPublic(generatedSkillset.encryptionKey)
    };
}
function publicSkillsetToGeneratedSkillset(skillset) {
    return {
        name: skillset.name,
        description: skillset.description,
        etag: skillset.etag,
        skills: skillset.skills,
        cognitiveServicesAccount: convertCognitiveServicesAccountToGenerated(skillset.cognitiveServicesAccount),
        knowledgeStore: skillset.knowledgeStore,
        encryptionKey: convertEncryptionKeyToGenerated(skillset.encryptionKey)
    };
}
function generatedSynonymMapToPublicSynonymMap(synonymMap) {
    const result = {
        name: synonymMap.name,
        encryptionKey: convertEncryptionKeyToPublic(synonymMap.encryptionKey),
        etag: synonymMap.etag,
        synonyms: []
    };
    if (synonymMap.synonyms) {
        result.synonyms = synonymMap.synonyms.split("\n");
    }
    return result;
}
function publicSynonymMapToGeneratedSynonymMap(synonymMap) {
    const result = {
        name: synonymMap.name,
        format: "solr",
        encryptionKey: convertEncryptionKeyToGenerated(synonymMap.encryptionKey),
        etag: synonymMap.etag,
        synonyms: synonymMap.synonyms.join("\n")
    };
    result.encryptionKey = convertEncryptionKeyToGenerated(synonymMap.encryptionKey);
    return result;
}
function publicSearchIndexerToGeneratedSearchIndexer(indexer) {
    return Object.assign(Object.assign({}, indexer), { encryptionKey: convertEncryptionKeyToGenerated(indexer.encryptionKey) });
}
function generatedSearchIndexerToPublicSearchIndexer(indexer) {
    return Object.assign(Object.assign({}, indexer), { encryptionKey: convertEncryptionKeyToPublic(indexer.encryptionKey) });
}
function publicDataSourceToGeneratedDataSource(dataSource) {
    return {
        name: dataSource.name,
        description: dataSource.description,
        type: dataSource.type,
        credentials: {
            connectionString: dataSource.connectionString
        },
        container: dataSource.container,
        etag: dataSource.etag,
        dataChangeDetectionPolicy: dataSource.dataChangeDetectionPolicy,
        dataDeletionDetectionPolicy: dataSource.dataDeletionDetectionPolicy,
        encryptionKey: convertEncryptionKeyToGenerated(dataSource.encryptionKey)
    };
}
function generatedDataSourceToPublicDataSource(dataSource) {
    return {
        name: dataSource.name,
        description: dataSource.name,
        type: dataSource.type,
        connectionString: dataSource.credentials.connectionString,
        container: dataSource.container,
        etag: dataSource.etag,
        dataChangeDetectionPolicy: convertDataChangeDetectionPolicyToPublic(dataSource.dataChangeDetectionPolicy),
        dataDeletionDetectionPolicy: convertDataDeletionDetectionPolicyToPublic(dataSource.dataDeletionDetectionPolicy),
        encryptionKey: convertEncryptionKeyToPublic(dataSource.encryptionKey)
    };
}
function convertDataChangeDetectionPolicyToPublic(dataChangeDetectionPolicy) {
    if (!dataChangeDetectionPolicy) {
        return dataChangeDetectionPolicy;
    }
    if (dataChangeDetectionPolicy.odatatype ===
        "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy") {
        return dataChangeDetectionPolicy;
    }
    else {
        return dataChangeDetectionPolicy;
    }
}
function convertDataDeletionDetectionPolicyToPublic(dataDeletionDetectionPolicy) {
    if (!dataDeletionDetectionPolicy) {
        return dataDeletionDetectionPolicy;
    }
    return dataDeletionDetectionPolicy;
}
function getRandomIntegerInclusive(min, max) {
    // Make sure inputs are integers.
    min = Math.ceil(min);
    max = Math.floor(max);
    // Pick a random offset from zero to the size of the range.
    // Since Math.random() can never return 1, we have to make the range one larger
    // in order to be inclusive of the maximum value after we take the floor.
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
}

// Copyright (c) Microsoft Corporation.
(function (KnownSearchAudience) {
    /**
     * Audience for Azure China
     */
    KnownSearchAudience["AzureChina"] = "https://search.azure.cn";
    /**
     * Audience for Azure Government
     */
    KnownSearchAudience["AzureGovernment"] = "https://search.azure.us";
    /**
     * Audience for Azure Public
     */
    KnownSearchAudience["AzurePublicCloud"] = "https://search.azure.com";
})(exports.KnownSearchAudience || (exports.KnownSearchAudience = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Class used to perform operations against a search index,
 * including querying documents in the index as well as
 * adding, updating, and removing them.
 */
class SearchClient$1 {
    /**
     * Creates an instance of SearchClient.
     *
     * Example usage:
     * ```ts
     * const { SearchClient, AzureKeyCredential } = require("@azure/search-documents");
     *
     * const client = new SearchClient(
     *   "<endpoint>",
     *   "<indexName>",
     *   new AzureKeyCredential("<Admin Key>");
     * );
     * ```
     * @param endpoint - The endpoint of the search service
     * @param indexName - The name of the index
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Search client.
     */
    constructor(endpoint, indexName, credential, options = {}) {
        /// Maintenance note: when updating supported API versions,
        /// the ContinuationToken logic will need to be updated below.
        /**
         * The API version to use when communicating with the service.
         */
        this.apiVersion = "2020-06-30-Preview";
        this.endpoint = endpoint;
        this.indexName = indexName;
        const libInfo = `azsdk-js-search-documents/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        if (options.userAgentOptions.userAgentPrefix) {
            options.userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            options.userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: [
                    "elapsed-time",
                    "Location",
                    "OData-MaxVersion",
                    "OData-Version",
                    "Prefer",
                    "throttle-reason"
                ]
            }
        });
        const scope = options.audience
            ? `${options.audience}/.default`
            : `${exports.KnownSearchAudience.AzurePublicCloud}/.default`;
        const requestPolicyFactory = coreAuth.isTokenCredential(credential)
            ? coreHttp.bearerTokenAuthenticationPolicy(credential, scope)
            : createSearchApiKeyCredentialPolicy(credential);
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, requestPolicyFactory);
        if (Array.isArray(pipeline.requestPolicyFactories)) {
            pipeline.requestPolicyFactories.unshift(odataMetadataPolicy("none"));
        }
        let apiVersion = this.apiVersion;
        if (options.apiVersion) {
            if (!["2020-06-30-Preview", "2020-06-30"].includes(options.apiVersion)) {
                throw new Error(`Invalid Api Version: ${options.apiVersion}`);
            }
            apiVersion = options.apiVersion;
        }
        this.client = new SearchClient(this.endpoint, this.indexName, apiVersion, pipeline);
    }
    /**
     * Retrieves the number of documents in the index.
     * @param options - Options to the count operation.
     */
    async getDocumentsCount(options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-getDocumentsCount", options);
        try {
            const result = await this.client.documents.count(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return Number(result._response.bodyAsText);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Based on a partial searchText from the user, return a list
     * of potential completion strings based on a specified suggester.
     * @param searchText - The search text on which to base autocomplete results.
     * @param suggesterName - The name of the suggester as specified in the suggesters collection that's part of the index definition.
     * @param options - Options to the autocomplete operation.
     */
    async autocomplete(searchText, suggesterName, options = {}) {
        const { operationOptions, restOptions } = this.extractOperationOptions(Object.assign({}, options));
        const { searchFields } = restOptions, nonFieldOptions = tslib.__rest(restOptions, ["searchFields"]);
        const fullOptions = Object.assign({ searchText: searchText, suggesterName: suggesterName, searchFields: this.convertSearchFields(searchFields) }, nonFieldOptions);
        if (!fullOptions.searchText) {
            throw new RangeError("searchText must be provided.");
        }
        if (!fullOptions.suggesterName) {
            throw new RangeError("suggesterName must be provided.");
        }
        const { span, updatedOptions } = createSpan("SearchClient-autocomplete", operationOptions);
        try {
            const result = await this.client.documents.autocompletePost(fullOptions, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return result;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async searchDocuments(searchText, options = {}, nextPageParameters = {}) {
        const { operationOptions, restOptions } = this.extractOperationOptions(Object.assign({}, options));
        const { select, searchFields, orderBy } = restOptions, nonFieldOptions = tslib.__rest(restOptions, ["select", "searchFields", "orderBy"]);
        const fullOptions = Object.assign(Object.assign({ searchFields: this.convertSearchFields(searchFields), select: this.convertSelect(select), orderBy: this.convertOrderBy(orderBy) }, nonFieldOptions), nextPageParameters);
        const { span, updatedOptions } = createSpan("SearchClient-searchDocuments", operationOptions);
        try {
            const result = await this.client.documents.searchPost(Object.assign(Object.assign({}, fullOptions), { includeTotalResultCount: fullOptions.includeTotalCount, searchText: searchText }), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            const { results, count, coverage, facets, nextLink } = result;
            const modifiedResults = generatedSearchResultToPublicSearchResult(results);
            const converted = {
                results: modifiedResults,
                count,
                coverage,
                facets,
                continuationToken: this.encodeContinuationToken(nextLink, result.nextPageParameters)
            };
            return deserialize(converted);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    listSearchResultsPage(searchText, options = {}, settings = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSearchResultsPage_1() {
            let decodedContinuation = this.decodeContinuationToken(settings.continuationToken);
            let result = yield tslib.__await(this.searchDocuments(searchText, options, decodedContinuation === null || decodedContinuation === void 0 ? void 0 : decodedContinuation.nextPageParameters));
            yield yield tslib.__await(result);
            // Technically, we should also leverage nextLink, but the generated code
            // doesn't support this yet.
            while (result.continuationToken) {
                decodedContinuation = this.decodeContinuationToken(result.continuationToken);
                result = yield tslib.__await(this.searchDocuments(searchText, options, decodedContinuation === null || decodedContinuation === void 0 ? void 0 : decodedContinuation.nextPageParameters));
                yield yield tslib.__await(result);
            }
        });
    }
    listSearchResultsAll(firstPage, searchText, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSearchResultsAll_1() {
            var e_1, _a;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(firstPage.results)));
            if (firstPage.continuationToken) {
                try {
                    for (var _b = tslib.__asyncValues(this.listSearchResultsPage(searchText, options, {
                        continuationToken: firstPage.continuationToken
                    })), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                        const page = _c.value;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page.results)));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        });
    }
    listSearchResults(firstPage, searchText, options = {}) {
        const iter = this.listSearchResultsAll(firstPage, searchText, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                return this.listSearchResultsPage(searchText, options, settings);
            }
        };
    }
    /**
     * Performs a search on the current index given
     * the specified arguments.
     * @param searchText - Text to search
     * @param options - Options for the search operation.
     */
    async search(searchText, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-search", options);
        try {
            const pageResult = await this.searchDocuments(searchText, updatedOptions);
            const { count, coverage, facets } = pageResult;
            return {
                count,
                coverage,
                facets,
                results: this.listSearchResults(pageResult, searchText, updatedOptions)
            };
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns a short list of suggestions based on the searchText
     * and specified suggester.
     * @param searchText - The search text to use to suggest documents. Must be at least 1 character, and no more than 100 characters.
     * @param suggesterName - The name of the suggester as specified in the suggesters collection that's part of the index definition.
     * @param options - Options for the suggest operation
     */
    async suggest(searchText, suggesterName, options = {}) {
        const { operationOptions, restOptions } = this.extractOperationOptions(Object.assign({}, options));
        const { select, searchFields, orderBy } = restOptions, nonFieldOptions = tslib.__rest(restOptions, ["select", "searchFields", "orderBy"]);
        const fullOptions = Object.assign({ searchText: searchText, suggesterName: suggesterName, searchFields: this.convertSearchFields(searchFields), select: this.convertSelect(select), orderBy: this.convertOrderBy(orderBy) }, nonFieldOptions);
        if (!fullOptions.searchText) {
            throw new RangeError("searchText must be provided.");
        }
        if (!fullOptions.suggesterName) {
            throw new RangeError("suggesterName must be provided.");
        }
        const { span, updatedOptions } = createSpan("SearchClient-suggest", operationOptions);
        try {
            const result = await this.client.documents.suggestPost(fullOptions, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            const modifiedResult = generatedSuggestDocumentsResultToPublicSuggestDocumentsResult(result);
            return deserialize(modifiedResult);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieve a particular document from the index by key.
     * @param key - The primary key value of the document
     * @param options - Additional options
     */
    async getDocument(key, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-getDocument", options);
        try {
            const result = await this.client.documents.get(key, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return deserialize(result.body);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Perform a set of index modifications (upload, merge, mergeOrUpload, delete)
     * for the given set of documents.
     * This operation may partially succeed and not all document operations will
     * be reflected in the index. If you would like to treat this as an exception,
     * set the `throwOnAnyFailure` option to true.
     * For more details about how merging works, see: https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param batch - An array of actions to perform on the index.
     * @param options - Additional options.
     */
    async indexDocuments(
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    batch, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-indexDocuments", options);
        try {
            const result = await this.client.documents.index({ actions: serialize(batch.actions) }, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            if (options.throwOnAnyFailure && result._response.status === 207) {
                throw result;
            }
            return result;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Upload an array of documents to the index.
     * @param documents - The documents to upload.
     * @param options - Additional options.
     */
    async uploadDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-uploadDocuments", options);
        const batch = new IndexDocumentsBatch();
        batch.upload(documents);
        try {
            return await this.indexDocuments(batch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Update a set of documents in the index.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents - The updated documents.
     * @param options - Additional options.
     */
    async mergeDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-mergeDocuments", options);
        const batch = new IndexDocumentsBatch();
        batch.merge(documents);
        try {
            return await this.indexDocuments(batch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Update a set of documents in the index or upload them if they don't exist.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents - The updated documents.
     * @param options - Additional options.
     */
    async mergeOrUploadDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-mergeDocuments", options);
        const batch = new IndexDocumentsBatch();
        batch.mergeOrUpload(documents);
        try {
            return await this.indexDocuments(batch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async deleteDocuments(keyNameOrDocuments, keyValuesOrOptions, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-deleteDocuments", options);
        const batch = new IndexDocumentsBatch();
        if (typeof keyNameOrDocuments === "string") {
            batch.delete(keyNameOrDocuments, keyValuesOrOptions);
        }
        else {
            batch.delete(keyNameOrDocuments);
        }
        try {
            return await this.indexDocuments(batch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    encodeContinuationToken(nextLink, nextPageParameters) {
        if (!nextLink || !nextPageParameters) {
            return undefined;
        }
        const payload = JSON.stringify({
            apiVersion: this.apiVersion,
            nextLink,
            nextPageParameters
        });
        return encode(payload);
    }
    decodeContinuationToken(token) {
        if (!token) {
            return undefined;
        }
        const decodedToken = decode(token);
        try {
            const result = JSON.parse(decodedToken);
            if (result.apiVersion !== this.apiVersion) {
                throw new RangeError(`Continuation token uses unsupported apiVersion "${this.apiVersion}"`);
            }
            return {
                nextLink: result.nextLink,
                nextPageParameters: result.nextPageParameters
            };
        }
        catch (e) {
            throw new Error(`Corrupted or invalid continuation token: ${decodedToken}`);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-shadow
    extractOperationOptions(obj) {
        const { abortSignal, requestOptions, tracingOptions } = obj, restOptions = tslib.__rest(obj, ["abortSignal", "requestOptions", "tracingOptions"]);
        return {
            operationOptions: {
                abortSignal,
                requestOptions,
                tracingOptions
            },
            restOptions
        };
    }
    convertSelect(select) {
        if (select) {
            return select.join(",");
        }
        return select;
    }
    convertSearchFields(searchFields) {
        if (searchFields) {
            return searchFields.join(",");
        }
        return searchFields;
    }
    convertOrderBy(orderBy) {
        if (orderBy) {
            return orderBy.join(",");
        }
        return orderBy;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Default Batch Size
 */
const DEFAULT_BATCH_SIZE = 512;
/**
 * Default window flush interval
 */
const DEFAULT_FLUSH_WINDOW = 60000;
/**
 * Default number of times to retry.
 */
const DEFAULT_RETRY_COUNT = 3;
/**
 * Default Max Delay between retries.
 */
const DEFAULT_MAX_RETRY_DELAY = 60000;
/**
 * Class used to perform buffered operations against a search index,
 * including adding, updating, and removing them.
 */
class SearchIndexingBufferedSender {
    /**
     * Creates a new instance of SearchIndexingBufferedSender.
     *
     * @param client - Search Client used to call the underlying IndexBatch operations.
     * @param options - Options to modify auto flush.
     *
     */
    constructor(client, documentKeyRetriever, options = {}) {
        var _a, _b, _c, _d, _e, _f;
        /**
         * Event emitter/publisher used in the Buffered Sender
         */
        this.emitter = new EventEmitter();
        this.client = client;
        this.documentKeyRetriever = documentKeyRetriever;
        // General Configuration properties
        this.autoFlush = (_a = options.autoFlush) !== null && _a !== void 0 ? _a : true;
        this.initialBatchActionCount = (_b = options.initialBatchActionCount) !== null && _b !== void 0 ? _b : DEFAULT_BATCH_SIZE;
        this.flushWindowInMs = (_c = options.flushWindowInMs) !== null && _c !== void 0 ? _c : DEFAULT_FLUSH_WINDOW;
        // Retry specific configuration properties
        this.throttlingDelayInMs = (_d = options.throttlingDelayInMs) !== null && _d !== void 0 ? _d : DEFAULT_FLUSH_WINDOW;
        this.maxRetriesPerAction = (_e = options.maxRetriesPerAction) !== null && _e !== void 0 ? _e : DEFAULT_RETRY_COUNT;
        this.maxThrottlingDelayInMs = (_f = options.maxThrottlingDelayInMs) !== null && _f !== void 0 ? _f : DEFAULT_MAX_RETRY_DELAY;
        this.batchObject = new IndexDocumentsBatch();
        if (this.autoFlush) {
            const interval = setInterval(() => this.flush(), this.flushWindowInMs);
            interval === null || interval === void 0 ? void 0 : interval.unref();
            this.cleanupTimer = () => {
                clearInterval(interval);
            };
        }
    }
    /**
     * Uploads the documents/Adds the documents to the upload queue.
     *
     * @param documents - Documents to be uploaded.
     * @param options - Upload options.
     */
    async uploadDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexingBufferedSender-uploadDocuments", options);
        try {
            this.batchObject.upload(documents);
            this.emitter.emit("batchAdded", {
                action: "upload",
                documents
            });
            return this.internalFlush(false, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Merges the documents/Adds the documents to the merge queue.
     *
     * @param documents - Documents to be merged.
     * @param options - Upload options.
     */
    async mergeDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexingBufferedSender-mergeDocuments", options);
        try {
            this.batchObject.merge(documents);
            this.emitter.emit("batchAdded", {
                action: "merge",
                documents
            });
            return this.internalFlush(false, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Merges/Uploads the documents/Adds the documents to the merge/upload queue.
     *
     * @param documents - Documents to be merged/uploaded.
     * @param options - Upload options.
     */
    async mergeOrUploadDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexingBufferedSender-mergeOrUploadDocuments", options);
        try {
            this.batchObject.mergeOrUpload(documents);
            this.emitter.emit("batchAdded", {
                action: "mergeOrUpload",
                documents
            });
            return this.internalFlush(false, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes the documents/Adds the documents to the delete queue.
     *
     * @param documents - Documents to be deleted.
     * @param options - Upload options.
     */
    async deleteDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexingBufferedSender-deleteDocuments", options);
        try {
            this.batchObject.delete(documents);
            this.emitter.emit("batchAdded", {
                action: "delete",
                documents
            });
            return this.internalFlush(false, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Flushes the queue manually.
     *
     * @param options - Flush options.
     */
    async flush(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexingBufferedSender-flush", options);
        try {
            if (this.batchObject.actions.length > 0) {
                return this.internalFlush(true, updatedOptions);
            }
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * If using autoFlush: true, call this to cleanup the autoflush timer.
     */
    async dispose() {
        if (this.batchObject.actions.length > 0) {
            await this.internalFlush(true);
        }
        if (this.cleanupTimer) {
            this.cleanupTimer();
        }
    }
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    off(event, listener) {
        this.emitter.removeListener(event, listener);
    }
    isBatchReady() {
        return this.batchObject.actions.length >= this.initialBatchActionCount;
    }
    async internalFlush(force, options = {}) {
        if (force || (this.autoFlush && this.isBatchReady())) {
            // Split it
            const actions = this.batchObject.actions;
            this.batchObject = new IndexDocumentsBatch();
            while (actions.length > 0) {
                const actionsToSend = actions.splice(0, this.initialBatchActionCount);
                const { batchToSubmit, submitLater } = this.pruneActions(actionsToSend);
                actions.unshift(...submitLater);
                await this.submitDocuments(batchToSubmit, options);
            }
        }
    }
    pruneActions(batch) {
        const hashSet = new Set();
        const resultBatch = [];
        const pruned = [];
        for (const document of batch) {
            const key = this.documentKeyRetriever(document);
            if (hashSet.has(key)) {
                pruned.push(document);
            }
            else {
                hashSet.add(key);
                resultBatch.push(document);
            }
        }
        return { batchToSubmit: resultBatch, submitLater: pruned };
    }
    async submitDocuments(actionsToSend, options, retryAttempt = 1) {
        try {
            for (const action of actionsToSend) {
                this.emitter.emit("beforeDocumentSent", action);
            }
            const result = await this.client.indexDocuments(new IndexDocumentsBatch(actionsToSend), options);
            // raise success event
            this.emitter.emit("batchSucceeded", result);
        }
        catch (e) {
            if (e.statusCode && e.statusCode === 413 && actionsToSend.length > 1) {
                // Cut the payload size to half
                const splitActionsArray = [
                    actionsToSend.slice(0, actionsToSend.length / 2),
                    actionsToSend.slice(actionsToSend.length / 2, actionsToSend.length)
                ];
                this.initialBatchActionCount = splitActionsArray[0].length; // So, we do not want 413 happening again and again
                for (const actions of splitActionsArray) {
                    await this.submitDocuments(actions, options);
                }
            }
            else if (this.isRetryAbleError(e) && retryAttempt <= this.maxRetriesPerAction) {
                // Exponentially increase the delay each time
                const exponentialDelay = this.throttlingDelayInMs * Math.pow(2, retryAttempt);
                // Don't let the delay exceed the maximum
                const clampedExponentialDelay = Math.min(this.maxThrottlingDelayInMs, exponentialDelay);
                // Allow the final value to have some "jitter" (within 50% of the delay size) so
                // that retries across multiple clients don't occur simultaneously.
                const delayWithJitter = clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);
                await coreHttp.delay(delayWithJitter);
                await this.submitDocuments(actionsToSend, options, retryAttempt + 1);
            }
            else {
                this.emitter.emit("batchFailed", e);
                throw e;
            }
        }
    }
    isRetryAbleError(e) {
        return e.statusCode && (e.statusCode === 422 || e.statusCode === 409 || e.statusCode === 503);
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const SearchIndexerDataSource = {
    type: {
        name: "Composite",
        className: "SearchIndexerDataSource",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "DataSourceCredentials"
                }
            },
            container: {
                serializedName: "container",
                type: {
                    name: "Composite",
                    className: "SearchIndexerDataContainer"
                }
            },
            dataChangeDetectionPolicy: {
                serializedName: "dataChangeDetectionPolicy",
                type: {
                    name: "Composite",
                    className: "DataChangeDetectionPolicy"
                }
            },
            dataDeletionDetectionPolicy: {
                serializedName: "dataDeletionDetectionPolicy",
                type: {
                    name: "Composite",
                    className: "DataDeletionDetectionPolicy"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            },
            encryptionKey: {
                serializedName: "encryptionKey",
                type: {
                    name: "Composite",
                    className: "SearchResourceEncryptionKey"
                }
            }
        }
    }
};
const DataSourceCredentials = {
    type: {
        name: "Composite",
        className: "DataSourceCredentials",
        modelProperties: {
            connectionString: {
                serializedName: "connectionString",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerDataContainer = {
    type: {
        name: "Composite",
        className: "SearchIndexerDataContainer",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            query: {
                serializedName: "query",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataChangeDetectionPolicy = {
    type: {
        name: "Composite",
        className: "DataChangeDetectionPolicy",
        uberParent: "DataChangeDetectionPolicy",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataDeletionDetectionPolicy = {
    type: {
        name: "Composite",
        className: "DataDeletionDetectionPolicy",
        uberParent: "DataDeletionDetectionPolicy",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchResourceEncryptionKey = {
    type: {
        name: "Composite",
        className: "SearchResourceEncryptionKey",
        modelProperties: {
            keyName: {
                serializedName: "keyVaultKeyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                serializedName: "keyVaultKeyVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            vaultUri: {
                serializedName: "keyVaultUri",
                required: true,
                type: {
                    name: "String"
                }
            },
            accessCredentials: {
                serializedName: "accessCredentials",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectoryApplicationCredentials"
                }
            }
        }
    }
};
const AzureActiveDirectoryApplicationCredentials = {
    type: {
        name: "Composite",
        className: "AzureActiveDirectoryApplicationCredentials",
        modelProperties: {
            applicationId: {
                serializedName: "applicationId",
                required: true,
                type: {
                    name: "String"
                }
            },
            applicationSecret: {
                serializedName: "applicationSecret",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchError$1 = {
    type: {
        name: "Composite",
        className: "SearchError",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchError"
                        }
                    }
                }
            }
        }
    }
};
const ListDataSourcesResult = {
    type: {
        name: "Composite",
        className: "ListDataSourcesResult",
        modelProperties: {
            dataSources: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerDataSource"
                        }
                    }
                }
            }
        }
    }
};
const SearchIndexer = {
    type: {
        name: "Composite",
        className: "SearchIndexer",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            dataSourceName: {
                serializedName: "dataSourceName",
                required: true,
                type: {
                    name: "String"
                }
            },
            skillsetName: {
                serializedName: "skillsetName",
                type: {
                    name: "String"
                }
            },
            targetIndexName: {
                serializedName: "targetIndexName",
                required: true,
                type: {
                    name: "String"
                }
            },
            schedule: {
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "IndexingSchedule"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "IndexingParameters"
                }
            },
            fieldMappings: {
                serializedName: "fieldMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FieldMapping"
                        }
                    }
                }
            },
            outputFieldMappings: {
                serializedName: "outputFieldMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FieldMapping"
                        }
                    }
                }
            },
            isDisabled: {
                serializedName: "disabled",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            },
            encryptionKey: {
                serializedName: "encryptionKey",
                type: {
                    name: "Composite",
                    className: "SearchResourceEncryptionKey"
                }
            }
        }
    }
};
const IndexingSchedule = {
    type: {
        name: "Composite",
        className: "IndexingSchedule",
        modelProperties: {
            interval: {
                serializedName: "interval",
                required: true,
                type: {
                    name: "TimeSpan"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const IndexingParameters = {
    type: {
        name: "Composite",
        className: "IndexingParameters",
        modelProperties: {
            batchSize: {
                serializedName: "batchSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            maxFailedItems: {
                serializedName: "maxFailedItems",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            maxFailedItemsPerBatch: {
                serializedName: "maxFailedItemsPerBatch",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            configuration: {
                serializedName: "configuration",
                type: {
                    name: "Composite",
                    className: "IndexingParametersConfiguration"
                }
            }
        }
    }
};
const IndexingParametersConfiguration = {
    type: {
        name: "Composite",
        className: "IndexingParametersConfiguration",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            parsingMode: {
                defaultValue: "default",
                serializedName: "parsingMode",
                type: {
                    name: "String"
                }
            },
            excludedFileNameExtensions: {
                serializedName: "excludedFileNameExtensions",
                type: {
                    name: "String"
                }
            },
            indexedFileNameExtensions: {
                serializedName: "indexedFileNameExtensions",
                type: {
                    name: "String"
                }
            },
            failOnUnsupportedContentType: {
                serializedName: "failOnUnsupportedContentType",
                type: {
                    name: "Boolean"
                }
            },
            failOnUnprocessableDocument: {
                serializedName: "failOnUnprocessableDocument",
                type: {
                    name: "Boolean"
                }
            },
            indexStorageMetadataOnlyForOversizedDocuments: {
                serializedName: "indexStorageMetadataOnlyForOversizedDocuments",
                type: {
                    name: "Boolean"
                }
            },
            delimitedTextHeaders: {
                serializedName: "delimitedTextHeaders",
                type: {
                    name: "String"
                }
            },
            delimitedTextDelimiter: {
                serializedName: "delimitedTextDelimiter",
                type: {
                    name: "String"
                }
            },
            firstLineContainsHeaders: {
                defaultValue: true,
                serializedName: "firstLineContainsHeaders",
                type: {
                    name: "Boolean"
                }
            },
            documentRoot: {
                serializedName: "documentRoot",
                type: {
                    name: "String"
                }
            },
            dataToExtract: {
                defaultValue: "contentAndMetadata",
                serializedName: "dataToExtract",
                type: {
                    name: "String"
                }
            },
            imageAction: {
                defaultValue: "none",
                serializedName: "imageAction",
                type: {
                    name: "String"
                }
            },
            allowSkillsetToReadFileData: {
                serializedName: "allowSkillsetToReadFileData",
                type: {
                    name: "Boolean"
                }
            },
            pdfTextRotationAlgorithm: {
                defaultValue: "none",
                serializedName: "pdfTextRotationAlgorithm",
                type: {
                    name: "String"
                }
            },
            executionEnvironment: {
                defaultValue: "standard",
                serializedName: "executionEnvironment",
                type: {
                    name: "String"
                }
            },
            queryTimeout: {
                defaultValue: "00:05:00",
                serializedName: "queryTimeout",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FieldMapping = {
    type: {
        name: "Composite",
        className: "FieldMapping",
        modelProperties: {
            sourceFieldName: {
                serializedName: "sourceFieldName",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetFieldName: {
                serializedName: "targetFieldName",
                type: {
                    name: "String"
                }
            },
            mappingFunction: {
                serializedName: "mappingFunction",
                type: {
                    name: "Composite",
                    className: "FieldMappingFunction"
                }
            }
        }
    }
};
const FieldMappingFunction = {
    type: {
        name: "Composite",
        className: "FieldMappingFunction",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const ListIndexersResult = {
    type: {
        name: "Composite",
        className: "ListIndexersResult",
        modelProperties: {
            indexers: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexer"
                        }
                    }
                }
            }
        }
    }
};
const SearchIndexerStatus = {
    type: {
        name: "Composite",
        className: "SearchIndexerStatus",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["unknown", "error", "running"]
                }
            },
            lastResult: {
                serializedName: "lastResult",
                type: {
                    name: "Composite",
                    className: "IndexerExecutionResult"
                }
            },
            executionHistory: {
                serializedName: "executionHistory",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IndexerExecutionResult"
                        }
                    }
                }
            },
            limits: {
                serializedName: "limits",
                type: {
                    name: "Composite",
                    className: "SearchIndexerLimits"
                }
            }
        }
    }
};
const IndexerExecutionResult = {
    type: {
        name: "Composite",
        className: "IndexerExecutionResult",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["transientFailure", "success", "inProgress", "reset"]
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                nullable: true,
                type: {
                    name: "DateTime"
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerError"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerWarning"
                        }
                    }
                }
            },
            itemCount: {
                serializedName: "itemsProcessed",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            failedItemCount: {
                serializedName: "itemsFailed",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            initialTrackingState: {
                serializedName: "initialTrackingState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            finalTrackingState: {
                serializedName: "finalTrackingState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerError = {
    type: {
        name: "Composite",
        className: "SearchIndexerError",
        modelProperties: {
            key: {
                serializedName: "key",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            documentationLink: {
                serializedName: "documentationLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerWarning = {
    type: {
        name: "Composite",
        className: "SearchIndexerWarning",
        modelProperties: {
            key: {
                serializedName: "key",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            documentationLink: {
                serializedName: "documentationLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerLimits = {
    type: {
        name: "Composite",
        className: "SearchIndexerLimits",
        modelProperties: {
            maxRunTime: {
                serializedName: "maxRunTime",
                readOnly: true,
                type: {
                    name: "TimeSpan"
                }
            },
            maxDocumentExtractionSize: {
                serializedName: "maxDocumentExtractionSize",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxDocumentContentCharactersToExtract: {
                serializedName: "maxDocumentContentCharactersToExtract",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SearchIndexerSkillset = {
    type: {
        name: "Composite",
        className: "SearchIndexerSkillset",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            skills: {
                serializedName: "skills",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerSkill"
                        }
                    }
                }
            },
            cognitiveServicesAccount: {
                serializedName: "cognitiveServices",
                type: {
                    name: "Composite",
                    className: "CognitiveServicesAccount"
                }
            },
            knowledgeStore: {
                serializedName: "knowledgeStore",
                type: {
                    name: "Composite",
                    className: "SearchIndexerKnowledgeStore"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            },
            encryptionKey: {
                serializedName: "encryptionKey",
                type: {
                    name: "Composite",
                    className: "SearchResourceEncryptionKey"
                }
            }
        }
    }
};
const SearchIndexerSkill = {
    type: {
        name: "Composite",
        className: "SearchIndexerSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            context: {
                serializedName: "context",
                type: {
                    name: "String"
                }
            },
            inputs: {
                serializedName: "inputs",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InputFieldMappingEntry"
                        }
                    }
                }
            },
            outputs: {
                serializedName: "outputs",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutputFieldMappingEntry"
                        }
                    }
                }
            }
        }
    }
};
const InputFieldMappingEntry = {
    type: {
        name: "Composite",
        className: "InputFieldMappingEntry",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "source",
                type: {
                    name: "String"
                }
            },
            sourceContext: {
                serializedName: "sourceContext",
                type: {
                    name: "String"
                }
            },
            inputs: {
                serializedName: "inputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InputFieldMappingEntry"
                        }
                    }
                }
            }
        }
    }
};
const OutputFieldMappingEntry = {
    type: {
        name: "Composite",
        className: "OutputFieldMappingEntry",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetName: {
                serializedName: "targetName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CognitiveServicesAccount = {
    type: {
        name: "Composite",
        className: "CognitiveServicesAccount",
        uberParent: "CognitiveServicesAccount",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerKnowledgeStore = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStore",
        modelProperties: {
            storageConnectionString: {
                serializedName: "storageConnectionString",
                required: true,
                type: {
                    name: "String"
                }
            },
            projections: {
                serializedName: "projections",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerKnowledgeStoreProjection"
                        }
                    }
                }
            }
        }
    }
};
const SearchIndexerKnowledgeStoreProjection = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStoreProjection",
        modelProperties: {
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerKnowledgeStoreTableProjectionSelector"
                        }
                    }
                }
            },
            objects: {
                serializedName: "objects",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerKnowledgeStoreObjectProjectionSelector"
                        }
                    }
                }
            },
            files: {
                serializedName: "files",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerKnowledgeStoreFileProjectionSelector"
                        }
                    }
                }
            }
        }
    }
};
const SearchIndexerKnowledgeStoreProjectionSelector = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStoreProjectionSelector",
        modelProperties: {
            referenceKeyName: {
                serializedName: "referenceKeyName",
                type: {
                    name: "String"
                }
            },
            generatedKeyName: {
                serializedName: "generatedKeyName",
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "source",
                type: {
                    name: "String"
                }
            },
            sourceContext: {
                serializedName: "sourceContext",
                type: {
                    name: "String"
                }
            },
            inputs: {
                serializedName: "inputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InputFieldMappingEntry"
                        }
                    }
                }
            }
        }
    }
};
const ListSkillsetsResult = {
    type: {
        name: "Composite",
        className: "ListSkillsetsResult",
        modelProperties: {
            skillsets: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerSkillset"
                        }
                    }
                }
            }
        }
    }
};
const SynonymMap = {
    type: {
        name: "Composite",
        className: "SynonymMap",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            format: {
                defaultValue: "solr",
                isConstant: true,
                serializedName: "format",
                type: {
                    name: "String"
                }
            },
            synonyms: {
                serializedName: "synonyms",
                required: true,
                type: {
                    name: "String"
                }
            },
            encryptionKey: {
                serializedName: "encryptionKey",
                type: {
                    name: "Composite",
                    className: "SearchResourceEncryptionKey"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListSynonymMapsResult = {
    type: {
        name: "Composite",
        className: "ListSynonymMapsResult",
        modelProperties: {
            synonymMaps: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SynonymMap"
                        }
                    }
                }
            }
        }
    }
};
const SearchIndex = {
    type: {
        name: "Composite",
        className: "SearchIndex",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchField"
                        }
                    }
                }
            },
            scoringProfiles: {
                serializedName: "scoringProfiles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScoringProfile"
                        }
                    }
                }
            },
            defaultScoringProfile: {
                serializedName: "defaultScoringProfile",
                type: {
                    name: "String"
                }
            },
            corsOptions: {
                serializedName: "corsOptions",
                type: {
                    name: "Composite",
                    className: "CorsOptions"
                }
            },
            suggesters: {
                serializedName: "suggesters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Suggester"
                        }
                    }
                }
            },
            analyzers: {
                serializedName: "analyzers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LexicalAnalyzer"
                        }
                    }
                }
            },
            tokenizers: {
                serializedName: "tokenizers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LexicalTokenizer"
                        }
                    }
                }
            },
            tokenFilters: {
                serializedName: "tokenFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TokenFilter"
                        }
                    }
                }
            },
            charFilters: {
                serializedName: "charFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CharFilter"
                        }
                    }
                }
            },
            encryptionKey: {
                serializedName: "encryptionKey",
                type: {
                    name: "Composite",
                    className: "SearchResourceEncryptionKey"
                }
            },
            similarity: {
                serializedName: "similarity",
                type: {
                    name: "Composite",
                    className: "Similarity"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchField = {
    type: {
        name: "Composite",
        className: "SearchField",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                type: {
                    name: "Boolean"
                }
            },
            retrievable: {
                serializedName: "retrievable",
                type: {
                    name: "Boolean"
                }
            },
            searchable: {
                serializedName: "searchable",
                type: {
                    name: "Boolean"
                }
            },
            filterable: {
                serializedName: "filterable",
                type: {
                    name: "Boolean"
                }
            },
            sortable: {
                serializedName: "sortable",
                type: {
                    name: "Boolean"
                }
            },
            facetable: {
                serializedName: "facetable",
                type: {
                    name: "Boolean"
                }
            },
            analyzer: {
                serializedName: "analyzer",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            searchAnalyzer: {
                serializedName: "searchAnalyzer",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            indexAnalyzer: {
                serializedName: "indexAnalyzer",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            synonymMaps: {
                serializedName: "synonymMaps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            fields: {
                serializedName: "fields",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchField"
                        }
                    }
                }
            }
        }
    }
};
const ScoringProfile = {
    type: {
        name: "Composite",
        className: "ScoringProfile",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            textWeights: {
                serializedName: "text",
                type: {
                    name: "Composite",
                    className: "TextWeights"
                }
            },
            functions: {
                serializedName: "functions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScoringFunction"
                        }
                    }
                }
            },
            functionAggregation: {
                serializedName: "functionAggregation",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "sum",
                        "average",
                        "minimum",
                        "maximum",
                        "firstMatching"
                    ]
                }
            }
        }
    }
};
const TextWeights = {
    type: {
        name: "Composite",
        className: "TextWeights",
        modelProperties: {
            weights: {
                serializedName: "weights",
                required: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            }
        }
    }
};
const ScoringFunction = {
    type: {
        name: "Composite",
        className: "ScoringFunction",
        uberParent: "ScoringFunction",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            fieldName: {
                serializedName: "fieldName",
                required: true,
                type: {
                    name: "String"
                }
            },
            boost: {
                serializedName: "boost",
                required: true,
                type: {
                    name: "Number"
                }
            },
            interpolation: {
                serializedName: "interpolation",
                type: {
                    name: "Enum",
                    allowedValues: ["linear", "constant", "quadratic", "logarithmic"]
                }
            }
        }
    }
};
const CorsOptions = {
    type: {
        name: "Composite",
        className: "CorsOptions",
        modelProperties: {
            allowedOrigins: {
                serializedName: "allowedOrigins",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            maxAgeInSeconds: {
                serializedName: "maxAgeInSeconds",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Suggester = {
    type: {
        name: "Composite",
        className: "Suggester",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            searchMode: {
                defaultValue: "analyzingInfixMatching",
                isConstant: true,
                serializedName: "searchMode",
                type: {
                    name: "String"
                }
            },
            sourceFields: {
                serializedName: "sourceFields",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const LexicalAnalyzer = {
    type: {
        name: "Composite",
        className: "LexicalAnalyzer",
        uberParent: "LexicalAnalyzer",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LexicalTokenizer = {
    type: {
        name: "Composite",
        className: "LexicalTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TokenFilter = {
    type: {
        name: "Composite",
        className: "TokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CharFilter = {
    type: {
        name: "Composite",
        className: "CharFilter",
        uberParent: "CharFilter",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Similarity = {
    type: {
        name: "Composite",
        className: "Similarity",
        uberParent: "Similarity",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListIndexesResult = {
    type: {
        name: "Composite",
        className: "ListIndexesResult",
        modelProperties: {
            indexes: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndex"
                        }
                    }
                }
            }
        }
    }
};
const GetIndexStatisticsResult = {
    type: {
        name: "Composite",
        className: "GetIndexStatisticsResult",
        modelProperties: {
            documentCount: {
                serializedName: "documentCount",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            storageSize: {
                serializedName: "storageSize",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AnalyzeRequest = {
    type: {
        name: "Composite",
        className: "AnalyzeRequest",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            analyzer: {
                serializedName: "analyzer",
                type: {
                    name: "String"
                }
            },
            tokenizer: {
                serializedName: "tokenizer",
                type: {
                    name: "String"
                }
            },
            tokenFilters: {
                serializedName: "tokenFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            charFilters: {
                serializedName: "charFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AnalyzeResult = {
    type: {
        name: "Composite",
        className: "AnalyzeResult",
        modelProperties: {
            tokens: {
                serializedName: "tokens",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AnalyzedTokenInfo"
                        }
                    }
                }
            }
        }
    }
};
const AnalyzedTokenInfo = {
    type: {
        name: "Composite",
        className: "AnalyzedTokenInfo",
        modelProperties: {
            token: {
                serializedName: "token",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startOffset: {
                serializedName: "startOffset",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            endOffset: {
                serializedName: "endOffset",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            position: {
                serializedName: "position",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServiceStatistics = {
    type: {
        name: "Composite",
        className: "ServiceStatistics",
        modelProperties: {
            counters: {
                serializedName: "counters",
                type: {
                    name: "Composite",
                    className: "ServiceCounters"
                }
            },
            limits: {
                serializedName: "limits",
                type: {
                    name: "Composite",
                    className: "ServiceLimits"
                }
            }
        }
    }
};
const ServiceCounters = {
    type: {
        name: "Composite",
        className: "ServiceCounters",
        modelProperties: {
            documentCounter: {
                serializedName: "documentCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            indexCounter: {
                serializedName: "indexesCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            indexerCounter: {
                serializedName: "indexersCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            dataSourceCounter: {
                serializedName: "dataSourcesCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            storageSizeCounter: {
                serializedName: "storageSize",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            synonymMapCounter: {
                serializedName: "synonymMaps",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            skillsetCounter: {
                serializedName: "skillsetCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            }
        }
    }
};
const ResourceCounter = {
    type: {
        name: "Composite",
        className: "ResourceCounter",
        modelProperties: {
            usage: {
                serializedName: "usage",
                required: true,
                type: {
                    name: "Number"
                }
            },
            quota: {
                serializedName: "quota",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServiceLimits = {
    type: {
        name: "Composite",
        className: "ServiceLimits",
        modelProperties: {
            maxFieldsPerIndex: {
                serializedName: "maxFieldsPerIndex",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            maxFieldNestingDepthPerIndex: {
                serializedName: "maxFieldNestingDepthPerIndex",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            maxComplexCollectionFieldsPerIndex: {
                serializedName: "maxComplexCollectionFieldsPerIndex",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            maxComplexObjectsInCollectionsPerDocument: {
                serializedName: "maxComplexObjectsInCollectionsPerDocument",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DistanceScoringParameters = {
    type: {
        name: "Composite",
        className: "DistanceScoringParameters",
        modelProperties: {
            referencePointParameter: {
                serializedName: "referencePointParameter",
                required: true,
                type: {
                    name: "String"
                }
            },
            boostingDistance: {
                serializedName: "boostingDistance",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const FreshnessScoringParameters = {
    type: {
        name: "Composite",
        className: "FreshnessScoringParameters",
        modelProperties: {
            boostingDuration: {
                serializedName: "boostingDuration",
                required: true,
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const MagnitudeScoringParameters = {
    type: {
        name: "Composite",
        className: "MagnitudeScoringParameters",
        modelProperties: {
            boostingRangeStart: {
                serializedName: "boostingRangeStart",
                required: true,
                type: {
                    name: "Number"
                }
            },
            boostingRangeEnd: {
                serializedName: "boostingRangeEnd",
                required: true,
                type: {
                    name: "Number"
                }
            },
            shouldBoostBeyondRangeByConstant: {
                serializedName: "constantBoostBeyondRange",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const TagScoringParameters = {
    type: {
        name: "Composite",
        className: "TagScoringParameters",
        modelProperties: {
            tagsParameter: {
                serializedName: "tagsParameter",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomEntity = {
    type: {
        name: "Composite",
        className: "CustomEntity",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            subtype: {
                serializedName: "subtype",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            caseSensitive: {
                serializedName: "caseSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            accentSensitive: {
                serializedName: "accentSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            fuzzyEditDistance: {
                serializedName: "fuzzyEditDistance",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            defaultCaseSensitive: {
                serializedName: "defaultCaseSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            defaultAccentSensitive: {
                serializedName: "defaultAccentSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            defaultFuzzyEditDistance: {
                serializedName: "defaultFuzzyEditDistance",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            aliases: {
                serializedName: "aliases",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomEntityAlias"
                        }
                    }
                }
            }
        }
    }
};
const CustomEntityAlias = {
    type: {
        name: "Composite",
        className: "CustomEntityAlias",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            caseSensitive: {
                serializedName: "caseSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            accentSensitive: {
                serializedName: "accentSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            fuzzyEditDistance: {
                serializedName: "fuzzyEditDistance",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const HighWaterMarkChangeDetectionPolicy = {
    serializedName: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
    type: {
        name: "Composite",
        className: "HighWaterMarkChangeDetectionPolicy",
        uberParent: "DataChangeDetectionPolicy",
        polymorphicDiscriminator: DataChangeDetectionPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DataChangeDetectionPolicy.type.modelProperties), { highWaterMarkColumnName: {
                serializedName: "highWaterMarkColumnName",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SqlIntegratedChangeTrackingPolicy = {
    serializedName: "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy",
    type: {
        name: "Composite",
        className: "SqlIntegratedChangeTrackingPolicy",
        uberParent: "DataChangeDetectionPolicy",
        polymorphicDiscriminator: DataChangeDetectionPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, DataChangeDetectionPolicy.type.modelProperties)
    }
};
const SoftDeleteColumnDeletionDetectionPolicy = {
    serializedName: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
    type: {
        name: "Composite",
        className: "SoftDeleteColumnDeletionDetectionPolicy",
        uberParent: "DataDeletionDetectionPolicy",
        polymorphicDiscriminator: DataDeletionDetectionPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DataDeletionDetectionPolicy.type.modelProperties), { softDeleteColumnName: {
                serializedName: "softDeleteColumnName",
                type: {
                    name: "String"
                }
            }, softDeleteMarkerValue: {
                serializedName: "softDeleteMarkerValue",
                type: {
                    name: "String"
                }
            } })
    }
};
const ConditionalSkill = {
    serializedName: "#Microsoft.Skills.Util.ConditionalSkill",
    type: {
        name: "Composite",
        className: "ConditionalSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, SearchIndexerSkill.type.modelProperties)
    }
};
const KeyPhraseExtractionSkill = {
    serializedName: "#Microsoft.Skills.Text.KeyPhraseExtractionSkill",
    type: {
        name: "Composite",
        className: "KeyPhraseExtractionSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, maxKeyPhraseCount: {
                serializedName: "maxKeyPhraseCount",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, modelVersion: {
                serializedName: "modelVersion",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const OcrSkill = {
    serializedName: "#Microsoft.Skills.Vision.OcrSkill",
    type: {
        name: "Composite",
        className: "OcrSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, shouldDetectOrientation: {
                serializedName: "detectOrientation",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ImageAnalysisSkill = {
    serializedName: "#Microsoft.Skills.Vision.ImageAnalysisSkill",
    type: {
        name: "Composite",
        className: "ImageAnalysisSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, visualFeatures: {
                serializedName: "visualFeatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const LanguageDetectionSkill = {
    serializedName: "#Microsoft.Skills.Text.LanguageDetectionSkill",
    type: {
        name: "Composite",
        className: "LanguageDetectionSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultCountryHint: {
                serializedName: "defaultCountryHint",
                nullable: true,
                type: {
                    name: "String"
                }
            }, modelVersion: {
                serializedName: "modelVersion",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ShaperSkill = {
    serializedName: "#Microsoft.Skills.Util.ShaperSkill",
    type: {
        name: "Composite",
        className: "ShaperSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, SearchIndexerSkill.type.modelProperties)
    }
};
const MergeSkill = {
    serializedName: "#Microsoft.Skills.Text.MergeSkill",
    type: {
        name: "Composite",
        className: "MergeSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { insertPreTag: {
                defaultValue: " ",
                serializedName: "insertPreTag",
                type: {
                    name: "String"
                }
            }, insertPostTag: {
                defaultValue: " ",
                serializedName: "insertPostTag",
                type: {
                    name: "String"
                }
            } })
    }
};
const EntityRecognitionSkill = {
    serializedName: "#Microsoft.Skills.Text.EntityRecognitionSkill",
    type: {
        name: "Composite",
        className: "EntityRecognitionSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { categories: {
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, includeTypelessEntities: {
                serializedName: "includeTypelessEntities",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            }, minimumPrecision: {
                serializedName: "minimumPrecision",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const SentimentSkill = {
    serializedName: "#Microsoft.Skills.Text.SentimentSkill",
    type: {
        name: "Composite",
        className: "SentimentSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            } })
    }
};
const SplitSkill = {
    serializedName: "#Microsoft.Skills.Text.SplitSkill",
    type: {
        name: "Composite",
        className: "SplitSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, textSplitMode: {
                serializedName: "textSplitMode",
                type: {
                    name: "String"
                }
            }, maxPageLength: {
                serializedName: "maximumPageLength",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const CustomEntityLookupSkill = {
    serializedName: "#Microsoft.Skills.Text.CustomEntityLookupSkill",
    type: {
        name: "Composite",
        className: "CustomEntityLookupSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                nullable: true,
                type: {
                    name: "String"
                }
            }, entitiesDefinitionUri: {
                serializedName: "entitiesDefinitionUri",
                nullable: true,
                type: {
                    name: "String"
                }
            }, inlineEntitiesDefinition: {
                serializedName: "inlineEntitiesDefinition",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomEntity"
                        }
                    }
                }
            }, globalDefaultCaseSensitive: {
                serializedName: "globalDefaultCaseSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            }, globalDefaultAccentSensitive: {
                serializedName: "globalDefaultAccentSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            }, globalDefaultFuzzyEditDistance: {
                serializedName: "globalDefaultFuzzyEditDistance",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const TextTranslationSkill = {
    serializedName: "#Microsoft.Skills.Text.TranslationSkill",
    type: {
        name: "Composite",
        className: "TextTranslationSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultToLanguageCode: {
                serializedName: "defaultToLanguageCode",
                required: true,
                type: {
                    name: "String"
                }
            }, defaultFromLanguageCode: {
                serializedName: "defaultFromLanguageCode",
                type: {
                    name: "String"
                }
            }, suggestedFrom: {
                serializedName: "suggestedFrom",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DocumentExtractionSkill = {
    serializedName: "#Microsoft.Skills.Util.DocumentExtractionSkill",
    type: {
        name: "Composite",
        className: "DocumentExtractionSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { parsingMode: {
                serializedName: "parsingMode",
                nullable: true,
                type: {
                    name: "String"
                }
            }, dataToExtract: {
                serializedName: "dataToExtract",
                nullable: true,
                type: {
                    name: "String"
                }
            }, configuration: {
                serializedName: "configuration",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const WebApiSkill = {
    serializedName: "#Microsoft.Skills.Custom.WebApiSkill",
    type: {
        name: "Composite",
        className: "WebApiSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { uri: {
                serializedName: "uri",
                required: true,
                type: {
                    name: "String"
                }
            }, httpHeaders: {
                serializedName: "httpHeaders",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, httpMethod: {
                serializedName: "httpMethod",
                type: {
                    name: "String"
                }
            }, timeout: {
                serializedName: "timeout",
                type: {
                    name: "TimeSpan"
                }
            }, batchSize: {
                serializedName: "batchSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, degreeOfParallelism: {
                serializedName: "degreeOfParallelism",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const DefaultCognitiveServicesAccount = {
    serializedName: "#Microsoft.Azure.Search.DefaultCognitiveServices",
    type: {
        name: "Composite",
        className: "DefaultCognitiveServicesAccount",
        uberParent: "CognitiveServicesAccount",
        polymorphicDiscriminator: CognitiveServicesAccount.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, CognitiveServicesAccount.type.modelProperties)
    }
};
const CognitiveServicesAccountKey = {
    serializedName: "#Microsoft.Azure.Search.CognitiveServicesByKey",
    type: {
        name: "Composite",
        className: "CognitiveServicesAccountKey",
        uberParent: "CognitiveServicesAccount",
        polymorphicDiscriminator: CognitiveServicesAccount.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CognitiveServicesAccount.type.modelProperties), { key: {
                serializedName: "key",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SearchIndexerKnowledgeStoreTableProjectionSelector = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStoreTableProjectionSelector",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerKnowledgeStoreProjectionSelector.type.modelProperties), { tableName: {
                serializedName: "tableName",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SearchIndexerKnowledgeStoreBlobProjectionSelector = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStoreBlobProjectionSelector",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerKnowledgeStoreProjectionSelector.type.modelProperties), { storageContainer: {
                serializedName: "storageContainer",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DistanceScoringFunction = {
    serializedName: "distance",
    type: {
        name: "Composite",
        className: "DistanceScoringFunction",
        uberParent: "ScoringFunction",
        polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScoringFunction.type.modelProperties), { parameters: {
                serializedName: "distance",
                type: {
                    name: "Composite",
                    className: "DistanceScoringParameters"
                }
            } })
    }
};
const FreshnessScoringFunction = {
    serializedName: "freshness",
    type: {
        name: "Composite",
        className: "FreshnessScoringFunction",
        uberParent: "ScoringFunction",
        polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScoringFunction.type.modelProperties), { parameters: {
                serializedName: "freshness",
                type: {
                    name: "Composite",
                    className: "FreshnessScoringParameters"
                }
            } })
    }
};
const MagnitudeScoringFunction = {
    serializedName: "magnitude",
    type: {
        name: "Composite",
        className: "MagnitudeScoringFunction",
        uberParent: "ScoringFunction",
        polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScoringFunction.type.modelProperties), { parameters: {
                serializedName: "magnitude",
                type: {
                    name: "Composite",
                    className: "MagnitudeScoringParameters"
                }
            } })
    }
};
const TagScoringFunction = {
    serializedName: "tag",
    type: {
        name: "Composite",
        className: "TagScoringFunction",
        uberParent: "ScoringFunction",
        polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScoringFunction.type.modelProperties), { parameters: {
                serializedName: "tag",
                type: {
                    name: "Composite",
                    className: "TagScoringParameters"
                }
            } })
    }
};
const CustomAnalyzer = {
    serializedName: "#Microsoft.Azure.Search.CustomAnalyzer",
    type: {
        name: "Composite",
        className: "CustomAnalyzer",
        uberParent: "LexicalAnalyzer",
        polymorphicDiscriminator: LexicalAnalyzer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalAnalyzer.type.modelProperties), { tokenizerName: {
                serializedName: "tokenizer",
                required: true,
                type: {
                    name: "String"
                }
            }, tokenFilters: {
                serializedName: "tokenFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, charFilters: {
                serializedName: "charFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const PatternAnalyzer = {
    serializedName: "#Microsoft.Azure.Search.PatternAnalyzer",
    type: {
        name: "Composite",
        className: "PatternAnalyzer",
        uberParent: "LexicalAnalyzer",
        polymorphicDiscriminator: LexicalAnalyzer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalAnalyzer.type.modelProperties), { lowerCaseTerms: {
                defaultValue: true,
                serializedName: "lowercase",
                type: {
                    name: "Boolean"
                }
            }, pattern: {
                defaultValue: "W+",
                serializedName: "pattern",
                type: {
                    name: "String"
                }
            }, flags: {
                serializedName: "flags",
                type: {
                    name: "String"
                }
            }, stopwords: {
                serializedName: "stopwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const LuceneStandardAnalyzer = {
    serializedName: "#Microsoft.Azure.Search.StandardAnalyzer",
    type: {
        name: "Composite",
        className: "LuceneStandardAnalyzer",
        uberParent: "LexicalAnalyzer",
        polymorphicDiscriminator: LexicalAnalyzer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalAnalyzer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            }, stopwords: {
                serializedName: "stopwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StopAnalyzer = {
    serializedName: "#Microsoft.Azure.Search.StopAnalyzer",
    type: {
        name: "Composite",
        className: "StopAnalyzer",
        uberParent: "LexicalAnalyzer",
        polymorphicDiscriminator: LexicalAnalyzer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalAnalyzer.type.modelProperties), { stopwords: {
                serializedName: "stopwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ClassicTokenizer = {
    serializedName: "#Microsoft.Azure.Search.ClassicTokenizer",
    type: {
        name: "Composite",
        className: "ClassicTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            } })
    }
};
const EdgeNGramTokenizer = {
    serializedName: "#Microsoft.Azure.Search.EdgeNGramTokenizer",
    type: {
        name: "Composite",
        className: "EdgeNGramTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { minGram: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "minGram",
                type: {
                    name: "Number"
                }
            }, maxGram: {
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxGram",
                type: {
                    name: "Number"
                }
            }, tokenChars: {
                serializedName: "tokenChars",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "letter",
                                "digit",
                                "whitespace",
                                "punctuation",
                                "symbol"
                            ]
                        }
                    }
                }
            } })
    }
};
const KeywordTokenizer = {
    serializedName: "#Microsoft.Azure.Search.KeywordTokenizer",
    type: {
        name: "Composite",
        className: "KeywordTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { bufferSize: {
                defaultValue: 256,
                serializedName: "bufferSize",
                type: {
                    name: "Number"
                }
            } })
    }
};
const KeywordTokenizerV2 = {
    serializedName: "#Microsoft.Azure.Search.KeywordTokenizerV2",
    type: {
        name: "Composite",
        className: "KeywordTokenizerV2",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 256,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            } })
    }
};
const MicrosoftLanguageTokenizer = {
    serializedName: "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer",
    type: {
        name: "Composite",
        className: "MicrosoftLanguageTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            }, isSearchTokenizer: {
                serializedName: "isSearchTokenizer",
                type: {
                    name: "Boolean"
                }
            }, language: {
                serializedName: "language",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "bangla",
                        "bulgarian",
                        "catalan",
                        "chineseSimplified",
                        "chineseTraditional",
                        "croatian",
                        "czech",
                        "danish",
                        "dutch",
                        "english",
                        "french",
                        "german",
                        "greek",
                        "gujarati",
                        "hindi",
                        "icelandic",
                        "indonesian",
                        "italian",
                        "japanese",
                        "kannada",
                        "korean",
                        "malay",
                        "malayalam",
                        "marathi",
                        "norwegianBokmaal",
                        "polish",
                        "portuguese",
                        "portugueseBrazilian",
                        "punjabi",
                        "romanian",
                        "russian",
                        "serbianCyrillic",
                        "serbianLatin",
                        "slovenian",
                        "spanish",
                        "swedish",
                        "tamil",
                        "telugu",
                        "thai",
                        "ukrainian",
                        "urdu",
                        "vietnamese"
                    ]
                }
            } })
    }
};
const MicrosoftLanguageStemmingTokenizer = {
    serializedName: "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer",
    type: {
        name: "Composite",
        className: "MicrosoftLanguageStemmingTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            }, isSearchTokenizer: {
                serializedName: "isSearchTokenizer",
                type: {
                    name: "Boolean"
                }
            }, language: {
                serializedName: "language",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "arabic",
                        "bangla",
                        "bulgarian",
                        "catalan",
                        "croatian",
                        "czech",
                        "danish",
                        "dutch",
                        "english",
                        "estonian",
                        "finnish",
                        "french",
                        "german",
                        "greek",
                        "gujarati",
                        "hebrew",
                        "hindi",
                        "hungarian",
                        "icelandic",
                        "indonesian",
                        "italian",
                        "kannada",
                        "latvian",
                        "lithuanian",
                        "malay",
                        "malayalam",
                        "marathi",
                        "norwegianBokmaal",
                        "polish",
                        "portuguese",
                        "portugueseBrazilian",
                        "punjabi",
                        "romanian",
                        "russian",
                        "serbianCyrillic",
                        "serbianLatin",
                        "slovak",
                        "slovenian",
                        "spanish",
                        "swedish",
                        "tamil",
                        "telugu",
                        "turkish",
                        "ukrainian",
                        "urdu"
                    ]
                }
            } })
    }
};
const NGramTokenizer = {
    serializedName: "#Microsoft.Azure.Search.NGramTokenizer",
    type: {
        name: "Composite",
        className: "NGramTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { minGram: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "minGram",
                type: {
                    name: "Number"
                }
            }, maxGram: {
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxGram",
                type: {
                    name: "Number"
                }
            }, tokenChars: {
                serializedName: "tokenChars",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "letter",
                                "digit",
                                "whitespace",
                                "punctuation",
                                "symbol"
                            ]
                        }
                    }
                }
            } })
    }
};
const PathHierarchyTokenizerV2 = {
    serializedName: "#Microsoft.Azure.Search.PathHierarchyTokenizerV2",
    type: {
        name: "Composite",
        className: "PathHierarchyTokenizerV2",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { delimiter: {
                defaultValue: "/",
                serializedName: "delimiter",
                type: {
                    name: "String"
                }
            }, replacement: {
                defaultValue: "/",
                serializedName: "replacement",
                type: {
                    name: "String"
                }
            }, maxTokenLength: {
                defaultValue: 300,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            }, reverseTokenOrder: {
                serializedName: "reverse",
                type: {
                    name: "Boolean"
                }
            }, numberOfTokensToSkip: {
                serializedName: "skip",
                type: {
                    name: "Number"
                }
            } })
    }
};
const PatternTokenizer = {
    serializedName: "#Microsoft.Azure.Search.PatternTokenizer",
    type: {
        name: "Composite",
        className: "PatternTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { pattern: {
                defaultValue: "W+",
                serializedName: "pattern",
                type: {
                    name: "String"
                }
            }, flags: {
                serializedName: "flags",
                type: {
                    name: "String"
                }
            }, group: {
                defaultValue: -1,
                serializedName: "group",
                type: {
                    name: "Number"
                }
            } })
    }
};
const LuceneStandardTokenizer = {
    serializedName: "#Microsoft.Azure.Search.StandardTokenizer",
    type: {
        name: "Composite",
        className: "LuceneStandardTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            } })
    }
};
const LuceneStandardTokenizerV2 = {
    serializedName: "#Microsoft.Azure.Search.StandardTokenizerV2",
    type: {
        name: "Composite",
        className: "LuceneStandardTokenizerV2",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            } })
    }
};
const UaxUrlEmailTokenizer = {
    serializedName: "#Microsoft.Azure.Search.UaxUrlEmailTokenizer",
    type: {
        name: "Composite",
        className: "UaxUrlEmailTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            } })
    }
};
const AsciiFoldingTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter",
    type: {
        name: "Composite",
        className: "AsciiFoldingTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { preserveOriginal: {
                serializedName: "preserveOriginal",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const CjkBigramTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.CjkBigramTokenFilter",
    type: {
        name: "Composite",
        className: "CjkBigramTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { ignoreScripts: {
                serializedName: "ignoreScripts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: ["han", "hiragana", "katakana", "hangul"]
                        }
                    }
                }
            }, outputUnigrams: {
                serializedName: "outputUnigrams",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const CommonGramTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.CommonGramTokenFilter",
    type: {
        name: "Composite",
        className: "CommonGramTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { commonWords: {
                serializedName: "commonWords",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, ignoreCase: {
                serializedName: "ignoreCase",
                type: {
                    name: "Boolean"
                }
            }, useQueryMode: {
                serializedName: "queryMode",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DictionaryDecompounderTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter",
    type: {
        name: "Composite",
        className: "DictionaryDecompounderTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { wordList: {
                serializedName: "wordList",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, minWordSize: {
                defaultValue: 5,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "minWordSize",
                type: {
                    name: "Number"
                }
            }, minSubwordSize: {
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "minSubwordSize",
                type: {
                    name: "Number"
                }
            }, maxSubwordSize: {
                defaultValue: 15,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxSubwordSize",
                type: {
                    name: "Number"
                }
            }, onlyLongestMatch: {
                serializedName: "onlyLongestMatch",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const EdgeNGramTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.EdgeNGramTokenFilter",
    type: {
        name: "Composite",
        className: "EdgeNGramTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minGram: {
                defaultValue: 1,
                serializedName: "minGram",
                type: {
                    name: "Number"
                }
            }, maxGram: {
                defaultValue: 2,
                serializedName: "maxGram",
                type: {
                    name: "Number"
                }
            }, side: {
                serializedName: "side",
                type: {
                    name: "Enum",
                    allowedValues: ["front", "back"]
                }
            } })
    }
};
const EdgeNGramTokenFilterV2 = {
    serializedName: "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2",
    type: {
        name: "Composite",
        className: "EdgeNGramTokenFilterV2",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minGram: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "minGram",
                type: {
                    name: "Number"
                }
            }, maxGram: {
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxGram",
                type: {
                    name: "Number"
                }
            }, side: {
                serializedName: "side",
                type: {
                    name: "Enum",
                    allowedValues: ["front", "back"]
                }
            } })
    }
};
const ElisionTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.ElisionTokenFilter",
    type: {
        name: "Composite",
        className: "ElisionTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { articles: {
                serializedName: "articles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const KeepTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.KeepTokenFilter",
    type: {
        name: "Composite",
        className: "KeepTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { keepWords: {
                serializedName: "keepWords",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, lowerCaseKeepWords: {
                serializedName: "keepWordsCase",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const KeywordMarkerTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.KeywordMarkerTokenFilter",
    type: {
        name: "Composite",
        className: "KeywordMarkerTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { keywords: {
                serializedName: "keywords",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, ignoreCase: {
                serializedName: "ignoreCase",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const LengthTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.LengthTokenFilter",
    type: {
        name: "Composite",
        className: "LengthTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minLength: {
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "min",
                type: {
                    name: "Number"
                }
            }, maxLength: {
                defaultValue: 300,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "max",
                type: {
                    name: "Number"
                }
            } })
    }
};
const LimitTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.LimitTokenFilter",
    type: {
        name: "Composite",
        className: "LimitTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { maxTokenCount: {
                defaultValue: 1,
                serializedName: "maxTokenCount",
                type: {
                    name: "Number"
                }
            }, consumeAllTokens: {
                serializedName: "consumeAllTokens",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const NGramTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.NGramTokenFilter",
    type: {
        name: "Composite",
        className: "NGramTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minGram: {
                defaultValue: 1,
                serializedName: "minGram",
                type: {
                    name: "Number"
                }
            }, maxGram: {
                defaultValue: 2,
                serializedName: "maxGram",
                type: {
                    name: "Number"
                }
            } })
    }
};
const NGramTokenFilterV2 = {
    serializedName: "#Microsoft.Azure.Search.NGramTokenFilterV2",
    type: {
        name: "Composite",
        className: "NGramTokenFilterV2",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minGram: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "minGram",
                type: {
                    name: "Number"
                }
            }, maxGram: {
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxGram",
                type: {
                    name: "Number"
                }
            } })
    }
};
const PatternCaptureTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.PatternCaptureTokenFilter",
    type: {
        name: "Composite",
        className: "PatternCaptureTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { patterns: {
                serializedName: "patterns",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, preserveOriginal: {
                defaultValue: true,
                serializedName: "preserveOriginal",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const PatternReplaceTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.PatternReplaceTokenFilter",
    type: {
        name: "Composite",
        className: "PatternReplaceTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { pattern: {
                serializedName: "pattern",
                required: true,
                type: {
                    name: "String"
                }
            }, replacement: {
                serializedName: "replacement",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PhoneticTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.PhoneticTokenFilter",
    type: {
        name: "Composite",
        className: "PhoneticTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { encoder: {
                serializedName: "encoder",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "metaphone",
                        "doubleMetaphone",
                        "soundex",
                        "refinedSoundex",
                        "caverphone1",
                        "caverphone2",
                        "cologne",
                        "nysiis",
                        "koelnerPhonetik",
                        "haasePhonetik",
                        "beiderMorse"
                    ]
                }
            }, replaceOriginalTokens: {
                defaultValue: true,
                serializedName: "replace",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ShingleTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.ShingleTokenFilter",
    type: {
        name: "Composite",
        className: "ShingleTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { maxShingleSize: {
                defaultValue: 2,
                constraints: {
                    InclusiveMinimum: 2
                },
                serializedName: "maxShingleSize",
                type: {
                    name: "Number"
                }
            }, minShingleSize: {
                defaultValue: 2,
                constraints: {
                    InclusiveMinimum: 2
                },
                serializedName: "minShingleSize",
                type: {
                    name: "Number"
                }
            }, outputUnigrams: {
                defaultValue: true,
                serializedName: "outputUnigrams",
                type: {
                    name: "Boolean"
                }
            }, outputUnigramsIfNoShingles: {
                serializedName: "outputUnigramsIfNoShingles",
                type: {
                    name: "Boolean"
                }
            }, tokenSeparator: {
                defaultValue: " ",
                serializedName: "tokenSeparator",
                type: {
                    name: "String"
                }
            }, filterToken: {
                defaultValue: "_",
                serializedName: "filterToken",
                type: {
                    name: "String"
                }
            } })
    }
};
const SnowballTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.SnowballTokenFilter",
    type: {
        name: "Composite",
        className: "SnowballTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { language: {
                serializedName: "language",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "armenian",
                        "basque",
                        "catalan",
                        "danish",
                        "dutch",
                        "english",
                        "finnish",
                        "french",
                        "german",
                        "german2",
                        "hungarian",
                        "italian",
                        "kp",
                        "lovins",
                        "norwegian",
                        "porter",
                        "portuguese",
                        "romanian",
                        "russian",
                        "spanish",
                        "swedish",
                        "turkish"
                    ]
                }
            } })
    }
};
const StemmerTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.StemmerTokenFilter",
    type: {
        name: "Composite",
        className: "StemmerTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { language: {
                serializedName: "language",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "arabic",
                        "armenian",
                        "basque",
                        "brazilian",
                        "bulgarian",
                        "catalan",
                        "czech",
                        "danish",
                        "dutch",
                        "dutchKp",
                        "english",
                        "lightEnglish",
                        "minimalEnglish",
                        "possessiveEnglish",
                        "porter2",
                        "lovins",
                        "finnish",
                        "lightFinnish",
                        "french",
                        "lightFrench",
                        "minimalFrench",
                        "galician",
                        "minimalGalician",
                        "german",
                        "german2",
                        "lightGerman",
                        "minimalGerman",
                        "greek",
                        "hindi",
                        "hungarian",
                        "lightHungarian",
                        "indonesian",
                        "irish",
                        "italian",
                        "lightItalian",
                        "sorani",
                        "latvian",
                        "norwegian",
                        "lightNorwegian",
                        "minimalNorwegian",
                        "lightNynorsk",
                        "minimalNynorsk",
                        "portuguese",
                        "lightPortuguese",
                        "minimalPortuguese",
                        "portugueseRslp",
                        "romanian",
                        "russian",
                        "lightRussian",
                        "spanish",
                        "lightSpanish",
                        "swedish",
                        "lightSwedish",
                        "turkish"
                    ]
                }
            } })
    }
};
const StemmerOverrideTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.StemmerOverrideTokenFilter",
    type: {
        name: "Composite",
        className: "StemmerOverrideTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { rules: {
                serializedName: "rules",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StopwordsTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.StopwordsTokenFilter",
    type: {
        name: "Composite",
        className: "StopwordsTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { stopwords: {
                serializedName: "stopwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, stopwordsList: {
                serializedName: "stopwordsList",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "arabic",
                        "armenian",
                        "basque",
                        "brazilian",
                        "bulgarian",
                        "catalan",
                        "czech",
                        "danish",
                        "dutch",
                        "english",
                        "finnish",
                        "french",
                        "galician",
                        "german",
                        "greek",
                        "hindi",
                        "hungarian",
                        "indonesian",
                        "irish",
                        "italian",
                        "latvian",
                        "norwegian",
                        "persian",
                        "portuguese",
                        "romanian",
                        "russian",
                        "sorani",
                        "spanish",
                        "swedish",
                        "thai",
                        "turkish"
                    ]
                }
            }, ignoreCase: {
                serializedName: "ignoreCase",
                type: {
                    name: "Boolean"
                }
            }, removeTrailingStopWords: {
                defaultValue: true,
                serializedName: "removeTrailing",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const SynonymTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.SynonymTokenFilter",
    type: {
        name: "Composite",
        className: "SynonymTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { synonyms: {
                serializedName: "synonyms",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, ignoreCase: {
                serializedName: "ignoreCase",
                type: {
                    name: "Boolean"
                }
            }, expand: {
                defaultValue: true,
                serializedName: "expand",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const TruncateTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.TruncateTokenFilter",
    type: {
        name: "Composite",
        className: "TruncateTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { length: {
                defaultValue: 300,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "length",
                type: {
                    name: "Number"
                }
            } })
    }
};
const UniqueTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.UniqueTokenFilter",
    type: {
        name: "Composite",
        className: "UniqueTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { onlyOnSamePosition: {
                serializedName: "onlyOnSamePosition",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const WordDelimiterTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.WordDelimiterTokenFilter",
    type: {
        name: "Composite",
        className: "WordDelimiterTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { generateWordParts: {
                defaultValue: true,
                serializedName: "generateWordParts",
                type: {
                    name: "Boolean"
                }
            }, generateNumberParts: {
                defaultValue: true,
                serializedName: "generateNumberParts",
                type: {
                    name: "Boolean"
                }
            }, catenateWords: {
                serializedName: "catenateWords",
                type: {
                    name: "Boolean"
                }
            }, catenateNumbers: {
                serializedName: "catenateNumbers",
                type: {
                    name: "Boolean"
                }
            }, catenateAll: {
                serializedName: "catenateAll",
                type: {
                    name: "Boolean"
                }
            }, splitOnCaseChange: {
                defaultValue: true,
                serializedName: "splitOnCaseChange",
                type: {
                    name: "Boolean"
                }
            }, preserveOriginal: {
                serializedName: "preserveOriginal",
                type: {
                    name: "Boolean"
                }
            }, splitOnNumerics: {
                defaultValue: true,
                serializedName: "splitOnNumerics",
                type: {
                    name: "Boolean"
                }
            }, stemEnglishPossessive: {
                defaultValue: true,
                serializedName: "stemEnglishPossessive",
                type: {
                    name: "Boolean"
                }
            }, protectedWords: {
                serializedName: "protectedWords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const MappingCharFilter = {
    serializedName: "#Microsoft.Azure.Search.MappingCharFilter",
    type: {
        name: "Composite",
        className: "MappingCharFilter",
        uberParent: "CharFilter",
        polymorphicDiscriminator: CharFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CharFilter.type.modelProperties), { mappings: {
                serializedName: "mappings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const PatternReplaceCharFilter = {
    serializedName: "#Microsoft.Azure.Search.PatternReplaceCharFilter",
    type: {
        name: "Composite",
        className: "PatternReplaceCharFilter",
        uberParent: "CharFilter",
        polymorphicDiscriminator: CharFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CharFilter.type.modelProperties), { pattern: {
                serializedName: "pattern",
                required: true,
                type: {
                    name: "String"
                }
            }, replacement: {
                serializedName: "replacement",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ClassicSimilarity = {
    serializedName: "#Microsoft.Azure.Search.ClassicSimilarity",
    type: {
        name: "Composite",
        className: "ClassicSimilarity",
        uberParent: "Similarity",
        polymorphicDiscriminator: Similarity.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, Similarity.type.modelProperties)
    }
};
const BM25Similarity = {
    serializedName: "#Microsoft.Azure.Search.BM25Similarity",
    type: {
        name: "Composite",
        className: "BM25Similarity",
        uberParent: "Similarity",
        polymorphicDiscriminator: Similarity.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Similarity.type.modelProperties), { k1: {
                serializedName: "k1",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, b: {
                serializedName: "b",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const SearchIndexerKnowledgeStoreObjectProjectionSelector = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStoreObjectProjectionSelector",
        modelProperties: Object.assign({}, SearchIndexerKnowledgeStoreBlobProjectionSelector.type.modelProperties)
    }
};
const SearchIndexerKnowledgeStoreFileProjectionSelector = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStoreFileProjectionSelector",
        modelProperties: Object.assign({}, SearchIndexerKnowledgeStoreBlobProjectionSelector.type.modelProperties)
    }
};
let discriminators = {
    DataChangeDetectionPolicy: DataChangeDetectionPolicy,
    DataDeletionDetectionPolicy: DataDeletionDetectionPolicy,
    SearchIndexerSkill: SearchIndexerSkill,
    CognitiveServicesAccount: CognitiveServicesAccount,
    ScoringFunction: ScoringFunction,
    LexicalAnalyzer: LexicalAnalyzer,
    LexicalTokenizer: LexicalTokenizer,
    TokenFilter: TokenFilter,
    CharFilter: CharFilter,
    Similarity: Similarity,
    "DataChangeDetectionPolicy.#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy": HighWaterMarkChangeDetectionPolicy,
    "DataChangeDetectionPolicy.#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy": SqlIntegratedChangeTrackingPolicy,
    "DataDeletionDetectionPolicy.#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy": SoftDeleteColumnDeletionDetectionPolicy,
    "SearchIndexerSkill.#Microsoft.Skills.Util.ConditionalSkill": ConditionalSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.KeyPhraseExtractionSkill": KeyPhraseExtractionSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Vision.OcrSkill": OcrSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Vision.ImageAnalysisSkill": ImageAnalysisSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.LanguageDetectionSkill": LanguageDetectionSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Util.ShaperSkill": ShaperSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.MergeSkill": MergeSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.EntityRecognitionSkill": EntityRecognitionSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.SentimentSkill": SentimentSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.SplitSkill": SplitSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.CustomEntityLookupSkill": CustomEntityLookupSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.TranslationSkill": TextTranslationSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Util.DocumentExtractionSkill": DocumentExtractionSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Custom.WebApiSkill": WebApiSkill,
    "CognitiveServicesAccount.#Microsoft.Azure.Search.DefaultCognitiveServices": DefaultCognitiveServicesAccount,
    "CognitiveServicesAccount.#Microsoft.Azure.Search.CognitiveServicesByKey": CognitiveServicesAccountKey,
    "ScoringFunction.distance": DistanceScoringFunction,
    "ScoringFunction.freshness": FreshnessScoringFunction,
    "ScoringFunction.magnitude": MagnitudeScoringFunction,
    "ScoringFunction.tag": TagScoringFunction,
    "LexicalAnalyzer.#Microsoft.Azure.Search.CustomAnalyzer": CustomAnalyzer,
    "LexicalAnalyzer.#Microsoft.Azure.Search.PatternAnalyzer": PatternAnalyzer,
    "LexicalAnalyzer.#Microsoft.Azure.Search.StandardAnalyzer": LuceneStandardAnalyzer,
    "LexicalAnalyzer.#Microsoft.Azure.Search.StopAnalyzer": StopAnalyzer,
    "LexicalTokenizer.#Microsoft.Azure.Search.ClassicTokenizer": ClassicTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.EdgeNGramTokenizer": EdgeNGramTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.KeywordTokenizer": KeywordTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.KeywordTokenizerV2": KeywordTokenizerV2,
    "LexicalTokenizer.#Microsoft.Azure.Search.MicrosoftLanguageTokenizer": MicrosoftLanguageTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer": MicrosoftLanguageStemmingTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.NGramTokenizer": NGramTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.PathHierarchyTokenizerV2": PathHierarchyTokenizerV2,
    "LexicalTokenizer.#Microsoft.Azure.Search.PatternTokenizer": PatternTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.StandardTokenizer": LuceneStandardTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.StandardTokenizerV2": LuceneStandardTokenizerV2,
    "LexicalTokenizer.#Microsoft.Azure.Search.UaxUrlEmailTokenizer": UaxUrlEmailTokenizer,
    "TokenFilter.#Microsoft.Azure.Search.AsciiFoldingTokenFilter": AsciiFoldingTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.CjkBigramTokenFilter": CjkBigramTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.CommonGramTokenFilter": CommonGramTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter": DictionaryDecompounderTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.EdgeNGramTokenFilter": EdgeNGramTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.EdgeNGramTokenFilterV2": EdgeNGramTokenFilterV2,
    "TokenFilter.#Microsoft.Azure.Search.ElisionTokenFilter": ElisionTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.KeepTokenFilter": KeepTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.KeywordMarkerTokenFilter": KeywordMarkerTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.LengthTokenFilter": LengthTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.LimitTokenFilter": LimitTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.NGramTokenFilter": NGramTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.NGramTokenFilterV2": NGramTokenFilterV2,
    "TokenFilter.#Microsoft.Azure.Search.PatternCaptureTokenFilter": PatternCaptureTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.PatternReplaceTokenFilter": PatternReplaceTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.PhoneticTokenFilter": PhoneticTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.ShingleTokenFilter": ShingleTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.SnowballTokenFilter": SnowballTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.StemmerTokenFilter": StemmerTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.StemmerOverrideTokenFilter": StemmerOverrideTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.StopwordsTokenFilter": StopwordsTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.SynonymTokenFilter": SynonymTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.TruncateTokenFilter": TruncateTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.UniqueTokenFilter": UniqueTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.WordDelimiterTokenFilter": WordDelimiterTokenFilter,
    "CharFilter.#Microsoft.Azure.Search.MappingCharFilter": MappingCharFilter,
    "CharFilter.#Microsoft.Azure.Search.PatternReplaceCharFilter": PatternReplaceCharFilter,
    "Similarity.#Microsoft.Azure.Search.ClassicSimilarity": ClassicSimilarity,
    "Similarity.#Microsoft.Azure.Search.BM25Similarity": BM25Similarity
};

var Mappers$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SearchIndexerDataSource: SearchIndexerDataSource,
    DataSourceCredentials: DataSourceCredentials,
    SearchIndexerDataContainer: SearchIndexerDataContainer,
    DataChangeDetectionPolicy: DataChangeDetectionPolicy,
    DataDeletionDetectionPolicy: DataDeletionDetectionPolicy,
    SearchResourceEncryptionKey: SearchResourceEncryptionKey,
    AzureActiveDirectoryApplicationCredentials: AzureActiveDirectoryApplicationCredentials,
    SearchError: SearchError$1,
    ListDataSourcesResult: ListDataSourcesResult,
    SearchIndexer: SearchIndexer,
    IndexingSchedule: IndexingSchedule,
    IndexingParameters: IndexingParameters,
    IndexingParametersConfiguration: IndexingParametersConfiguration,
    FieldMapping: FieldMapping,
    FieldMappingFunction: FieldMappingFunction,
    ListIndexersResult: ListIndexersResult,
    SearchIndexerStatus: SearchIndexerStatus,
    IndexerExecutionResult: IndexerExecutionResult,
    SearchIndexerError: SearchIndexerError,
    SearchIndexerWarning: SearchIndexerWarning,
    SearchIndexerLimits: SearchIndexerLimits,
    SearchIndexerSkillset: SearchIndexerSkillset,
    SearchIndexerSkill: SearchIndexerSkill,
    InputFieldMappingEntry: InputFieldMappingEntry,
    OutputFieldMappingEntry: OutputFieldMappingEntry,
    CognitiveServicesAccount: CognitiveServicesAccount,
    SearchIndexerKnowledgeStore: SearchIndexerKnowledgeStore,
    SearchIndexerKnowledgeStoreProjection: SearchIndexerKnowledgeStoreProjection,
    SearchIndexerKnowledgeStoreProjectionSelector: SearchIndexerKnowledgeStoreProjectionSelector,
    ListSkillsetsResult: ListSkillsetsResult,
    SynonymMap: SynonymMap,
    ListSynonymMapsResult: ListSynonymMapsResult,
    SearchIndex: SearchIndex,
    SearchField: SearchField,
    ScoringProfile: ScoringProfile,
    TextWeights: TextWeights,
    ScoringFunction: ScoringFunction,
    CorsOptions: CorsOptions,
    Suggester: Suggester,
    LexicalAnalyzer: LexicalAnalyzer,
    LexicalTokenizer: LexicalTokenizer,
    TokenFilter: TokenFilter,
    CharFilter: CharFilter,
    Similarity: Similarity,
    ListIndexesResult: ListIndexesResult,
    GetIndexStatisticsResult: GetIndexStatisticsResult,
    AnalyzeRequest: AnalyzeRequest,
    AnalyzeResult: AnalyzeResult,
    AnalyzedTokenInfo: AnalyzedTokenInfo,
    ServiceStatistics: ServiceStatistics,
    ServiceCounters: ServiceCounters,
    ResourceCounter: ResourceCounter,
    ServiceLimits: ServiceLimits,
    DistanceScoringParameters: DistanceScoringParameters,
    FreshnessScoringParameters: FreshnessScoringParameters,
    MagnitudeScoringParameters: MagnitudeScoringParameters,
    TagScoringParameters: TagScoringParameters,
    CustomEntity: CustomEntity,
    CustomEntityAlias: CustomEntityAlias,
    HighWaterMarkChangeDetectionPolicy: HighWaterMarkChangeDetectionPolicy,
    SqlIntegratedChangeTrackingPolicy: SqlIntegratedChangeTrackingPolicy,
    SoftDeleteColumnDeletionDetectionPolicy: SoftDeleteColumnDeletionDetectionPolicy,
    ConditionalSkill: ConditionalSkill,
    KeyPhraseExtractionSkill: KeyPhraseExtractionSkill,
    OcrSkill: OcrSkill,
    ImageAnalysisSkill: ImageAnalysisSkill,
    LanguageDetectionSkill: LanguageDetectionSkill,
    ShaperSkill: ShaperSkill,
    MergeSkill: MergeSkill,
    EntityRecognitionSkill: EntityRecognitionSkill,
    SentimentSkill: SentimentSkill,
    SplitSkill: SplitSkill,
    CustomEntityLookupSkill: CustomEntityLookupSkill,
    TextTranslationSkill: TextTranslationSkill,
    DocumentExtractionSkill: DocumentExtractionSkill,
    WebApiSkill: WebApiSkill,
    DefaultCognitiveServicesAccount: DefaultCognitiveServicesAccount,
    CognitiveServicesAccountKey: CognitiveServicesAccountKey,
    SearchIndexerKnowledgeStoreTableProjectionSelector: SearchIndexerKnowledgeStoreTableProjectionSelector,
    SearchIndexerKnowledgeStoreBlobProjectionSelector: SearchIndexerKnowledgeStoreBlobProjectionSelector,
    DistanceScoringFunction: DistanceScoringFunction,
    FreshnessScoringFunction: FreshnessScoringFunction,
    MagnitudeScoringFunction: MagnitudeScoringFunction,
    TagScoringFunction: TagScoringFunction,
    CustomAnalyzer: CustomAnalyzer,
    PatternAnalyzer: PatternAnalyzer,
    LuceneStandardAnalyzer: LuceneStandardAnalyzer,
    StopAnalyzer: StopAnalyzer,
    ClassicTokenizer: ClassicTokenizer,
    EdgeNGramTokenizer: EdgeNGramTokenizer,
    KeywordTokenizer: KeywordTokenizer,
    KeywordTokenizerV2: KeywordTokenizerV2,
    MicrosoftLanguageTokenizer: MicrosoftLanguageTokenizer,
    MicrosoftLanguageStemmingTokenizer: MicrosoftLanguageStemmingTokenizer,
    NGramTokenizer: NGramTokenizer,
    PathHierarchyTokenizerV2: PathHierarchyTokenizerV2,
    PatternTokenizer: PatternTokenizer,
    LuceneStandardTokenizer: LuceneStandardTokenizer,
    LuceneStandardTokenizerV2: LuceneStandardTokenizerV2,
    UaxUrlEmailTokenizer: UaxUrlEmailTokenizer,
    AsciiFoldingTokenFilter: AsciiFoldingTokenFilter,
    CjkBigramTokenFilter: CjkBigramTokenFilter,
    CommonGramTokenFilter: CommonGramTokenFilter,
    DictionaryDecompounderTokenFilter: DictionaryDecompounderTokenFilter,
    EdgeNGramTokenFilter: EdgeNGramTokenFilter,
    EdgeNGramTokenFilterV2: EdgeNGramTokenFilterV2,
    ElisionTokenFilter: ElisionTokenFilter,
    KeepTokenFilter: KeepTokenFilter,
    KeywordMarkerTokenFilter: KeywordMarkerTokenFilter,
    LengthTokenFilter: LengthTokenFilter,
    LimitTokenFilter: LimitTokenFilter,
    NGramTokenFilter: NGramTokenFilter,
    NGramTokenFilterV2: NGramTokenFilterV2,
    PatternCaptureTokenFilter: PatternCaptureTokenFilter,
    PatternReplaceTokenFilter: PatternReplaceTokenFilter,
    PhoneticTokenFilter: PhoneticTokenFilter,
    ShingleTokenFilter: ShingleTokenFilter,
    SnowballTokenFilter: SnowballTokenFilter,
    StemmerTokenFilter: StemmerTokenFilter,
    StemmerOverrideTokenFilter: StemmerOverrideTokenFilter,
    StopwordsTokenFilter: StopwordsTokenFilter,
    SynonymTokenFilter: SynonymTokenFilter,
    TruncateTokenFilter: TruncateTokenFilter,
    UniqueTokenFilter: UniqueTokenFilter,
    WordDelimiterTokenFilter: WordDelimiterTokenFilter,
    MappingCharFilter: MappingCharFilter,
    PatternReplaceCharFilter: PatternReplaceCharFilter,
    ClassicSimilarity: ClassicSimilarity,
    BM25Similarity: BM25Similarity,
    SearchIndexerKnowledgeStoreObjectProjectionSelector: SearchIndexerKnowledgeStoreObjectProjectionSelector,
    SearchIndexerKnowledgeStoreFileProjectionSelector: SearchIndexerKnowledgeStoreFileProjectionSelector,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType$1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const dataSource = {
    parameterPath: "dataSource",
    mapper: SearchIndexerDataSource
};
const accept$1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint$1 = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const dataSourceName = {
    parameterPath: "dataSourceName",
    mapper: {
        serializedName: "dataSourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const xMsClientRequestId$1 = {
    parameterPath: ["options", "requestOptionsParam", "xMsClientRequestId"],
    mapper: {
        serializedName: "x-ms-client-request-id",
        type: {
            name: "Uuid"
        }
    }
};
const ifMatch = {
    parameterPath: ["options", "ifMatch"],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const ifNoneMatch = {
    parameterPath: ["options", "ifNoneMatch"],
    mapper: {
        serializedName: "If-None-Match",
        type: {
            name: "String"
        }
    }
};
const prefer = {
    parameterPath: "prefer",
    mapper: {
        defaultValue: "return=representation",
        isConstant: true,
        serializedName: "Prefer",
        type: {
            name: "String"
        }
    }
};
const apiVersion$1 = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const select$1 = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$select",
        type: {
            name: "String"
        }
    }
};
const indexerName = {
    parameterPath: "indexerName",
    mapper: {
        serializedName: "indexerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const indexer = {
    parameterPath: "indexer",
    mapper: SearchIndexer
};
const skillset = {
    parameterPath: "skillset",
    mapper: SearchIndexerSkillset
};
const skillsetName = {
    parameterPath: "skillsetName",
    mapper: {
        serializedName: "skillsetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const synonymMap = {
    parameterPath: "synonymMap",
    mapper: SynonymMap
};
const synonymMapName = {
    parameterPath: "synonymMapName",
    mapper: {
        serializedName: "synonymMapName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const index = {
    parameterPath: "index",
    mapper: SearchIndex
};
const indexName$1 = {
    parameterPath: "indexName",
    mapper: {
        serializedName: "indexName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const allowIndexDowntime = {
    parameterPath: ["options", "allowIndexDowntime"],
    mapper: {
        serializedName: "allowIndexDowntime",
        type: {
            name: "Boolean"
        }
    }
};
const request = {
    parameterPath: "request",
    mapper: AnalyzeRequest
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a DataSources. */
class DataSources {
    /**
     * Initialize a new instance of the class DataSources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new datasource or updates a datasource if it already exists.
     * @param dataSourceName The name of the datasource to create or update.
     * @param dataSource The definition of the datasource to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(dataSourceName, dataSource, options) {
        const operationArguments = {
            dataSourceName,
            dataSource,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOrUpdateOperationSpec);
    }
    /**
     * Deletes a datasource.
     * @param dataSourceName The name of the datasource to delete.
     * @param options The options parameters.
     */
    delete(dataSourceName, options) {
        const operationArguments = {
            dataSourceName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec);
    }
    /**
     * Retrieves a datasource definition.
     * @param dataSourceName The name of the datasource to retrieve.
     * @param options The options parameters.
     */
    get(dataSourceName, options) {
        const operationArguments = {
            dataSourceName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getOperationSpec$1);
    }
    /**
     * Lists all datasources available for a search service.
     * @param options The options parameters.
     */
    list(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listOperationSpec);
    }
    /**
     * Creates a new datasource.
     * @param dataSource The definition of the datasource to create.
     * @param options The options parameters.
     */
    create(dataSource, options) {
        const operationArguments = {
            dataSource,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = new coreHttp.Serializer(Mappers$1, /* isXml */ false);
const createOrUpdateOperationSpec = {
    path: "/datasources('{dataSourceName}')",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SearchIndexerDataSource
        },
        201: {
            bodyMapper: SearchIndexerDataSource
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: dataSource,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, dataSourceName],
    headerParameters: [
        contentType$1,
        accept$1,
        xMsClientRequestId$1,
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec = {
    path: "/datasources('{dataSourceName}')",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, dataSourceName],
    headerParameters: [
        accept$1,
        xMsClientRequestId$1,
        ifMatch,
        ifNoneMatch
    ],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/datasources('{dataSourceName}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchIndexerDataSource
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, dataSourceName],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$1
};
const listOperationSpec = {
    path: "/datasources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListDataSourcesResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1, select$1],
    urlParameters: [endpoint$1],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$1
};
const createOperationSpec = {
    path: "/datasources",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: SearchIndexerDataSource
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: dataSource,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1],
    headerParameters: [
        contentType$1,
        accept$1,
        xMsClientRequestId$1
    ],
    mediaType: "json",
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a Indexers. */
class Indexers {
    /**
     * Initialize a new instance of the class Indexers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Resets the change tracking state associated with an indexer.
     * @param indexerName The name of the indexer to reset.
     * @param options The options parameters.
     */
    reset(indexerName, options) {
        const operationArguments = {
            indexerName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, resetOperationSpec);
    }
    /**
     * Runs an indexer on-demand.
     * @param indexerName The name of the indexer to run.
     * @param options The options parameters.
     */
    run(indexerName, options) {
        const operationArguments = {
            indexerName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, runOperationSpec);
    }
    /**
     * Creates a new indexer or updates an indexer if it already exists.
     * @param indexerName The name of the indexer to create or update.
     * @param indexer The definition of the indexer to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(indexerName, indexer, options) {
        const operationArguments = {
            indexerName,
            indexer,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOrUpdateOperationSpec$1);
    }
    /**
     * Deletes an indexer.
     * @param indexerName The name of the indexer to delete.
     * @param options The options parameters.
     */
    delete(indexerName, options) {
        const operationArguments = {
            indexerName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec$1);
    }
    /**
     * Retrieves an indexer definition.
     * @param indexerName The name of the indexer to retrieve.
     * @param options The options parameters.
     */
    get(indexerName, options) {
        const operationArguments = {
            indexerName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getOperationSpec$2);
    }
    /**
     * Lists all indexers available for a search service.
     * @param options The options parameters.
     */
    list(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listOperationSpec$1);
    }
    /**
     * Creates a new indexer.
     * @param indexer The definition of the indexer to create.
     * @param options The options parameters.
     */
    create(indexer, options) {
        const operationArguments = {
            indexer,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec$1);
    }
    /**
     * Returns the current status and execution history of an indexer.
     * @param indexerName The name of the indexer for which to retrieve status.
     * @param options The options parameters.
     */
    getStatus(indexerName, options) {
        const operationArguments = {
            indexerName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getStatusOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = new coreHttp.Serializer(Mappers$1, /* isXml */ false);
const resetOperationSpec = {
    path: "/indexers('{indexerName}')/search.reset",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexerName],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$2
};
const runOperationSpec = {
    path: "/indexers('{indexerName}')/search.run",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexerName],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$2
};
const createOrUpdateOperationSpec$1 = {
    path: "/indexers('{indexerName}')",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SearchIndexer
        },
        201: {
            bodyMapper: SearchIndexer
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: indexer,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexerName],
    headerParameters: [
        contentType$1,
        accept$1,
        xMsClientRequestId$1,
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$1 = {
    path: "/indexers('{indexerName}')",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexerName],
    headerParameters: [
        accept$1,
        xMsClientRequestId$1,
        ifMatch,
        ifNoneMatch
    ],
    serializer: serializer$2
};
const getOperationSpec$2 = {
    path: "/indexers('{indexerName}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchIndexer
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexerName],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$2
};
const listOperationSpec$1 = {
    path: "/indexers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListIndexersResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1, select$1],
    urlParameters: [endpoint$1],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$2
};
const createOperationSpec$1 = {
    path: "/indexers",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: SearchIndexer
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: indexer,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1],
    headerParameters: [
        contentType$1,
        accept$1,
        xMsClientRequestId$1
    ],
    mediaType: "json",
    serializer: serializer$2
};
const getStatusOperationSpec = {
    path: "/indexers('{indexerName}')/search.status",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchIndexerStatus
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexerName],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a Skillsets. */
class Skillsets {
    /**
     * Initialize a new instance of the class Skillsets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new skillset in a search service or updates the skillset if it already exists.
     * @param skillsetName The name of the skillset to create or update.
     * @param skillset The skillset containing one or more skills to create or update in a search service.
     * @param options The options parameters.
     */
    createOrUpdate(skillsetName, skillset, options) {
        const operationArguments = {
            skillsetName,
            skillset,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOrUpdateOperationSpec$2);
    }
    /**
     * Deletes a skillset in a search service.
     * @param skillsetName The name of the skillset to delete.
     * @param options The options parameters.
     */
    delete(skillsetName, options) {
        const operationArguments = {
            skillsetName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec$2);
    }
    /**
     * Retrieves a skillset in a search service.
     * @param skillsetName The name of the skillset to retrieve.
     * @param options The options parameters.
     */
    get(skillsetName, options) {
        const operationArguments = {
            skillsetName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getOperationSpec$3);
    }
    /**
     * List all skillsets in a search service.
     * @param options The options parameters.
     */
    list(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listOperationSpec$2);
    }
    /**
     * Creates a new skillset in a search service.
     * @param skillset The skillset containing one or more skills to create in a search service.
     * @param options The options parameters.
     */
    create(skillset, options) {
        const operationArguments = {
            skillset,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec$2);
    }
}
// Operation Specifications
const serializer$3 = new coreHttp.Serializer(Mappers$1, /* isXml */ false);
const createOrUpdateOperationSpec$2 = {
    path: "/skillsets('{skillsetName}')",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SearchIndexerSkillset
        },
        201: {
            bodyMapper: SearchIndexerSkillset
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: skillset,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, skillsetName],
    headerParameters: [
        contentType$1,
        accept$1,
        xMsClientRequestId$1,
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$2 = {
    path: "/skillsets('{skillsetName}')",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, skillsetName],
    headerParameters: [
        accept$1,
        xMsClientRequestId$1,
        ifMatch,
        ifNoneMatch
    ],
    serializer: serializer$3
};
const getOperationSpec$3 = {
    path: "/skillsets('{skillsetName}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchIndexerSkillset
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, skillsetName],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$3
};
const listOperationSpec$2 = {
    path: "/skillsets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListSkillsetsResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1, select$1],
    urlParameters: [endpoint$1],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$3
};
const createOperationSpec$2 = {
    path: "/skillsets",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: SearchIndexerSkillset
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: skillset,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1],
    headerParameters: [
        contentType$1,
        accept$1,
        xMsClientRequestId$1
    ],
    mediaType: "json",
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a SynonymMaps. */
class SynonymMaps {
    /**
     * Initialize a new instance of the class SynonymMaps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new synonym map or updates a synonym map if it already exists.
     * @param synonymMapName The name of the synonym map to create or update.
     * @param synonymMap The definition of the synonym map to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(synonymMapName, synonymMap, options) {
        const operationArguments = {
            synonymMapName,
            synonymMap,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOrUpdateOperationSpec$3);
    }
    /**
     * Deletes a synonym map.
     * @param synonymMapName The name of the synonym map to delete.
     * @param options The options parameters.
     */
    delete(synonymMapName, options) {
        const operationArguments = {
            synonymMapName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec$3);
    }
    /**
     * Retrieves a synonym map definition.
     * @param synonymMapName The name of the synonym map to retrieve.
     * @param options The options parameters.
     */
    get(synonymMapName, options) {
        const operationArguments = {
            synonymMapName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getOperationSpec$4);
    }
    /**
     * Lists all synonym maps available for a search service.
     * @param options The options parameters.
     */
    list(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listOperationSpec$3);
    }
    /**
     * Creates a new synonym map.
     * @param synonymMap The definition of the synonym map to create.
     * @param options The options parameters.
     */
    create(synonymMap, options) {
        const operationArguments = {
            synonymMap,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec$3);
    }
}
// Operation Specifications
const serializer$4 = new coreHttp.Serializer(Mappers$1, /* isXml */ false);
const createOrUpdateOperationSpec$3 = {
    path: "/synonymmaps('{synonymMapName}')",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SynonymMap
        },
        201: {
            bodyMapper: SynonymMap
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: synonymMap,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, synonymMapName],
    headerParameters: [
        contentType$1,
        accept$1,
        xMsClientRequestId$1,
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec$3 = {
    path: "/synonymmaps('{synonymMapName}')",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, synonymMapName],
    headerParameters: [
        accept$1,
        xMsClientRequestId$1,
        ifMatch,
        ifNoneMatch
    ],
    serializer: serializer$4
};
const getOperationSpec$4 = {
    path: "/synonymmaps('{synonymMapName}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SynonymMap
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, synonymMapName],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$4
};
const listOperationSpec$3 = {
    path: "/synonymmaps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListSynonymMapsResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1, select$1],
    urlParameters: [endpoint$1],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$4
};
const createOperationSpec$3 = {
    path: "/synonymmaps",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: SynonymMap
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: synonymMap,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1],
    headerParameters: [
        contentType$1,
        accept$1,
        xMsClientRequestId$1
    ],
    mediaType: "json",
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a Indexes. */
class Indexes {
    /**
     * Initialize a new instance of the class Indexes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new search index.
     * @param index The definition of the index to create.
     * @param options The options parameters.
     */
    create(index, options) {
        const operationArguments = {
            index,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec$4);
    }
    /**
     * Lists all indexes available for a search service.
     * @param options The options parameters.
     */
    list(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listOperationSpec$4);
    }
    /**
     * Creates a new search index or updates an index if it already exists.
     * @param indexName The definition of the index to create or update.
     * @param index The definition of the index to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(indexName, index, options) {
        const operationArguments = {
            indexName,
            index,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOrUpdateOperationSpec$4);
    }
    /**
     * Deletes a search index and all the documents it contains. This operation is permanent, with no
     * recovery option. Make sure you have a master copy of your index definition, data ingestion code, and
     * a backup of the primary data source in case you need to re-build the index.
     * @param indexName The name of the index to delete.
     * @param options The options parameters.
     */
    delete(indexName, options) {
        const operationArguments = {
            indexName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec$4);
    }
    /**
     * Retrieves an index definition.
     * @param indexName The name of the index to retrieve.
     * @param options The options parameters.
     */
    get(indexName, options) {
        const operationArguments = {
            indexName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getOperationSpec$5);
    }
    /**
     * Returns statistics for the given index, including a document count and storage usage.
     * @param indexName The name of the index for which to retrieve statistics.
     * @param options The options parameters.
     */
    getStatistics(indexName, options) {
        const operationArguments = {
            indexName,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getStatisticsOperationSpec);
    }
    /**
     * Shows how an analyzer breaks text into tokens.
     * @param indexName The name of the index for which to test an analyzer.
     * @param request The text and analyzer or analysis components to test.
     * @param options The options parameters.
     */
    analyze(indexName, request, options) {
        const operationArguments = {
            indexName,
            request,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, analyzeOperationSpec);
    }
}
// Operation Specifications
const serializer$5 = new coreHttp.Serializer(Mappers$1, /* isXml */ false);
const createOperationSpec$4 = {
    path: "/indexes",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: SearchIndex
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: index,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1],
    headerParameters: [
        contentType$1,
        accept$1,
        xMsClientRequestId$1
    ],
    mediaType: "json",
    serializer: serializer$5
};
const listOperationSpec$4 = {
    path: "/indexes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListIndexesResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1, select$1],
    urlParameters: [endpoint$1],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$5
};
const createOrUpdateOperationSpec$4 = {
    path: "/indexes('{indexName}')",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SearchIndex
        },
        201: {
            bodyMapper: SearchIndex
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: index,
    queryParameters: [apiVersion$1, allowIndexDowntime],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [
        contentType$1,
        accept$1,
        xMsClientRequestId$1,
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$4 = {
    path: "/indexes('{indexName}')",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [
        accept$1,
        xMsClientRequestId$1,
        ifMatch,
        ifNoneMatch
    ],
    serializer: serializer$5
};
const getOperationSpec$5 = {
    path: "/indexes('{indexName}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchIndex
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$5
};
const getStatisticsOperationSpec = {
    path: "/indexes('{indexName}')/search.stats",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetIndexStatisticsResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$5
};
const analyzeOperationSpec = {
    path: "/indexes('{indexName}')/search.analyze",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AnalyzeResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: request,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [
        contentType$1,
        accept$1,
        xMsClientRequestId$1
    ],
    mediaType: "json",
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const packageName$1 = "@azure/search-documents";
const packageVersion$1 = "11.3.1";
/** @internal */
class SearchServiceClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the SearchServiceClientContext class.
     * @param endpoint The endpoint URL of the search service.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(endpoint, apiVersion, options) {
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        if (apiVersion === undefined) {
            throw new Error("'apiVersion' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName$1}/${packageVersion$1} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri = options.endpoint || "{endpoint}";
        // Parameter assignments
        this.endpoint = endpoint;
        this.apiVersion = apiVersion;
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class SearchServiceClient extends SearchServiceClientContext {
    /**
     * Initializes a new instance of the SearchServiceClient class.
     * @param endpoint The endpoint URL of the search service.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(endpoint, apiVersion, options) {
        super(endpoint, apiVersion, options);
        this.dataSources = new DataSources(this);
        this.indexers = new Indexers(this);
        this.skillsets = new Skillsets(this);
        this.synonymMaps = new SynonymMaps(this);
        this.indexes = new Indexes(this);
    }
    /**
     * Gets service level statistics for a search service.
     * @param options The options parameters.
     */
    getServiceStatistics(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getServiceStatisticsOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = new coreHttp.Serializer(Mappers$1, /* isXml */ false);
const getServiceStatisticsOperationSpec = {
    path: "/servicestats",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceStatistics
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1],
    headerParameters: [accept$1, xMsClientRequestId$1],
    serializer: serializer$6
};

// Copyright (c) Microsoft Corporation.
/**
 * Class to perform operations to manage
 * (create, update, list/delete)
 * indexes, & synonymmaps.
 */
class SearchIndexClient {
    /**
     * Creates an instance of SearchIndexClient.
     *
     * Example usage:
     * ```ts
     * const { SearchIndexClient, AzureKeyCredential } = require("@azure/search-documents");
     *
     * const client = new SearchIndexClient(
     *   "<endpoint>",
     *   new AzureKeyCredential("<Admin Key>");
     * );
     * ```
     * @param endpoint - The endpoint of the search service
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Search Index client.
     */
    constructor(endpoint, credential, options = {}) {
        /**
         * The API version to use when communicating with the service.
         */
        this.apiVersion = "2020-06-30";
        this.endpoint = endpoint;
        this.credential = credential;
        this.options = options;
        const libInfo = `azsdk-js-search-documents/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        if (options.userAgentOptions.userAgentPrefix) {
            options.userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            options.userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: [
                    "elapsed-time",
                    "Location",
                    "OData-MaxVersion",
                    "OData-Version",
                    "Prefer",
                    "throttle-reason"
                ]
            }
        });
        const scope = options.audience
            ? `${options.audience}/.default`
            : `${exports.KnownSearchAudience.AzurePublicCloud}/.default`;
        const requestPolicyFactory = coreAuth.isTokenCredential(credential)
            ? coreHttp.bearerTokenAuthenticationPolicy(credential, scope)
            : createSearchApiKeyCredentialPolicy(credential);
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, requestPolicyFactory);
        if (Array.isArray(pipeline.requestPolicyFactories)) {
            pipeline.requestPolicyFactories.unshift(odataMetadataPolicy("minimal"));
        }
        let apiVersion = this.apiVersion;
        if (options.apiVersion) {
            if (!["2020-06-30-Preview", "2020-06-30"].includes(options.apiVersion)) {
                throw new Error(`Invalid Api Version: ${options.apiVersion}`);
            }
            apiVersion = options.apiVersion;
        }
        this.client = new SearchServiceClient(this.endpoint, apiVersion, pipeline);
    }
    listIndexesPage(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listIndexesPage_1() {
            const { span, updatedOptions } = createSpan("SearchIndexClient-listIndexesPage", options);
            try {
                const result = yield tslib.__await(this.client.indexes.list(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)));
                const mapped = result.indexes.map(generatedIndexToPublicIndex);
                yield yield tslib.__await(mapped);
            }
            catch (e) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listIndexesAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listIndexesAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listIndexesPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves a list of existing indexes in the service.
     * @param options - Options to the list index operation.
     */
    listIndexes(options = {}) {
        const iter = this.listIndexesAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listIndexesPage(options);
            }
        };
    }
    listIndexesNamesPage(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listIndexesNamesPage_1() {
            const { span, updatedOptions } = createSpan("SearchIndexClient-listIndexesNamesPage", options);
            try {
                const result = yield tslib.__await(this.client.indexes.list(Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { select: "name" })));
                const mapped = result.indexes.map((idx) => idx.name);
                yield yield tslib.__await(mapped);
            }
            catch (e) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listIndexesNamesAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listIndexesNamesAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listIndexesNamesPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves a list of names of existing indexes in the service.
     * @param options - Options to the list index operation.
     */
    listIndexesNames(options = {}) {
        const iter = this.listIndexesNamesAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listIndexesNamesPage(options);
            }
        };
    }
    /**
     * Retrieves a list of existing SynonymMaps in the service.
     * @param options - Options to the list SynonymMaps operation.
     */
    async listSynonymMaps(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-listSynonymMaps", options);
        try {
            const result = await this.client.synonymMaps.list(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return result.synonymMaps.map(generatedSynonymMapToPublicSynonymMap);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of names of existing SynonymMaps in the service.
     * @param options - Options to the list SynonymMaps operation.
     */
    async listSynonymMapsNames(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-listSynonymMapsNames", options);
        try {
            const result = await this.client.synonymMaps.list(Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { select: "name" }));
            return result.synonymMaps.map((sm) => sm.name);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves information about an index.
     * @param indexName - The name of the index.
     * @param options - Additional optional arguments.
     */
    async getIndex(indexName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-getIndex", options);
        try {
            const result = await this.client.indexes.get(indexName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return generatedIndexToPublicIndex(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves information about a SynonymMap.
     * @param synonymMapName - The name of the SynonymMap.
     * @param options - Additional optional arguments.
     */
    async getSynonymMap(synonymMapName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-getSynonymMaps", options);
        try {
            const result = await this.client.synonymMaps.get(synonymMapName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return generatedSynonymMapToPublicSynonymMap(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new index.
     * @param index - The information describing the index to be created.
     * @param options - Additional optional arguments.
     */
    async createIndex(index, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-createIndex", options);
        try {
            const result = await this.client.indexes.create(publicIndexToGeneratedIndex(index), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return generatedIndexToPublicIndex(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new SynonymMap in a search service.
     * @param synonymMap - The synonymMap definition to create in a search service.
     * @param options - Additional optional arguments.
     */
    async createSynonymMap(synonymMap, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-createSynonymMaps", options);
        try {
            const result = await this.client.synonymMaps.create(publicSynonymMapToGeneratedSynonymMap(synonymMap), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return generatedSynonymMapToPublicSynonymMap(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new index or modifies an existing one.
     * @param index - The information describing the index to be created.
     * @param options - Additional optional arguments.
     */
    async createOrUpdateIndex(index, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-createOrUpdateIndex", options);
        try {
            const etag = options.onlyIfUnchanged ? index.etag : undefined;
            const result = await this.client.indexes.createOrUpdate(index.name, publicIndexToGeneratedIndex(index), Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
            return generatedIndexToPublicIndex(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new SynonymMap or modifies an existing one.
     * @param synonymMap - The information describing the SynonymMap to be created.
     * @param options - Additional optional arguments.
     */
    async createOrUpdateSynonymMap(synonymMap, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-createOrUpdateSynonymMap", options);
        try {
            const etag = options.onlyIfUnchanged ? synonymMap.etag : undefined;
            const result = await this.client.synonymMaps.createOrUpdate(synonymMap.name, publicSynonymMapToGeneratedSynonymMap(synonymMap), Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
            return generatedSynonymMapToPublicSynonymMap(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes an existing index.
     * @param indexName - Index/Name of the index to delete.
     * @param options - Additional optional arguments.
     */
    async deleteIndex(index, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-deleteIndex", options);
        try {
            const indexName = typeof index === "string" ? index : index.name;
            const etag = typeof index === "string" ? undefined : options.onlyIfUnchanged ? index.etag : undefined;
            await this.client.indexes.delete(indexName, Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes an existing SynonymMap.
     * @param synonymMapName - SynonymMap/Name of the synonymMap to delete.
     * @param options - Additional optional arguments.
     */
    async deleteSynonymMap(synonymMap, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-deleteSynonymMap", options);
        try {
            const synonymMapName = typeof synonymMap === "string" ? synonymMap : synonymMap.name;
            const etag = typeof synonymMap === "string"
                ? undefined
                : options.onlyIfUnchanged
                    ? synonymMap.etag
                    : undefined;
            await this.client.synonymMaps.delete(synonymMapName, Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves statistics about an index, such as the count of documents and the size
     * of index storage.
     * @param indexName - The name of the index.
     * @param options - Additional optional arguments.
     */
    async getIndexStatistics(indexName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-getIndexStatistics", options);
        try {
            const result = await this.client.indexes.getStatistics(indexName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return result;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Calls an analyzer or tokenizer manually on provided text.
     * @param indexName - The name of the index that contains the field to analyze
     * @param text - The text to break into tokens.
     * @param options - Additional arguments
     */
    async analyzeText(indexName, options) {
        const { operationOptions, restOptions } = extractOperationOptions(options);
        const { span, updatedOptions } = createSpan("SearchIndexClient-analyzeText", operationOptions);
        try {
            const result = await this.client.indexes.analyze(indexName, Object.assign(Object.assign({}, restOptions), { analyzer: restOptions.analyzerName, tokenizer: restOptions.tokenizerName }), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return result;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves statistics about the service, such as the count of documents, index, etc.
     * @param options - Additional optional arguments.
     */
    async getServiceStatistics(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-getServiceStatistics", options);
        try {
            const result = await this.client.getServiceStatistics(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return result;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves the SearchClient corresponding to this SearchIndexClient
     * @param indexName - Name of the index
     * @param options - SearchClient Options
     */
    getSearchClient(indexName, options) {
        return new SearchClient$1(this.endpoint, indexName, this.credential, options || this.options);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Class to perform operations to manage
 * (create, update, list/delete)
 * indexers, datasources & skillsets.
 */
class SearchIndexerClient {
    /**
     * Creates an instance of SearchIndexerClient.
     *
     * Example usage:
     * ```ts
     * const { SearchIndexerClient, AzureKeyCredential } = require("@azure/search-documents");
     *
     * const client = new SearchIndexerClient(
     *   "<endpoint>",
     *   new AzureKeyCredential("<Admin Key>");
     * );
     * ```
     * @param endpoint - The endpoint of the search service
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Search client.
     */
    constructor(endpoint, credential, options = {}) {
        /**
         * The API version to use when communicating with the service.
         */
        this.apiVersion = "2020-06-30";
        this.endpoint = endpoint;
        const libInfo = `azsdk-js-search-documents/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        if (options.userAgentOptions.userAgentPrefix) {
            options.userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            options.userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: [
                    "elapsed-time",
                    "Location",
                    "OData-MaxVersion",
                    "OData-Version",
                    "Prefer",
                    "throttle-reason"
                ]
            }
        });
        const scope = options.audience
            ? `${options.audience}/.default`
            : `${exports.KnownSearchAudience.AzurePublicCloud}/.default`;
        const requestPolicyFactory = coreAuth.isTokenCredential(credential)
            ? coreHttp.bearerTokenAuthenticationPolicy(credential, scope)
            : createSearchApiKeyCredentialPolicy(credential);
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, requestPolicyFactory);
        if (Array.isArray(pipeline.requestPolicyFactories)) {
            pipeline.requestPolicyFactories.unshift(odataMetadataPolicy("minimal"));
        }
        let apiVersion = this.apiVersion;
        if (options.apiVersion) {
            if (!["2020-06-30-Preview", "2020-06-30"].includes(options.apiVersion)) {
                throw new Error(`Invalid Api Version: ${options.apiVersion}`);
            }
            apiVersion = options.apiVersion;
        }
        this.client = new SearchServiceClient(this.endpoint, apiVersion, pipeline);
    }
    /**
     * Retrieves a list of existing indexers in the service.
     * @param options - Options to the list indexers operation.
     */
    async listIndexers(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-listIndexers", options);
        try {
            const result = await this.client.indexers.list(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return result.indexers.map(generatedSearchIndexerToPublicSearchIndexer);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of names of existing indexers in the service.
     * @param options - Options to the list indexers operation.
     */
    async listIndexersNames(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-listIndexersNames", options);
        try {
            const result = await this.client.indexers.list(Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { select: "name" }));
            return result.indexers.map((idx) => idx.name);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of existing data sources in the service.
     * @param options - Options to the list indexers operation.
     */
    async listDataSourceConnections(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-listDataSourceConnections", options);
        try {
            const result = await this.client.dataSources.list(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return result.dataSources.map(generatedDataSourceToPublicDataSource);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of names of existing data sources in the service.
     * @param options - Options to the list indexers operation.
     */
    async listDataSourceConnectionsNames(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-listDataSourceConnectionsNames", options);
        try {
            const result = await this.client.dataSources.list(Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { select: "name" }));
            return result.dataSources.map((ds) => ds.name);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of existing Skillsets in the service.
     * @param options - Options to the list Skillsets operation.
     */
    async listSkillsets(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-listSkillsets", options);
        try {
            const result = await this.client.skillsets.list(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return result.skillsets.map(generatedSkillsetToPublicSkillset);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of names of existing Skillsets in the service.
     * @param options - Options to the list Skillsets operation.
     */
    async listSkillsetsNames(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-listSkillsetsNames", options);
        try {
            const result = await this.client.skillsets.list(Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { select: "name" }));
            return result.skillsets.map((sks) => sks.name);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves information about an Indexer.
     * @param indexerName - The name of the Indexer.
     * @param options - Additional optional arguments.
     */
    async getIndexer(indexerName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-getIndexer", options);
        try {
            const result = await this.client.indexers.get(indexerName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return generatedSearchIndexerToPublicSearchIndexer(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves information about a DataSource
     * @param dataSourceName - The name of the DataSource
     * @param options - Additional optional arguments
     */
    async getDataSourceConnection(dataSourceConnectionName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-getDataSourceConnection", options);
        try {
            const result = await this.client.dataSources.get(dataSourceConnectionName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return generatedDataSourceToPublicDataSource(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves information about an Skillset.
     * @param indexName - The name of the Skillset.
     * @param options - Additional optional arguments.
     */
    async getSkillset(skillsetName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-getSkillset", options);
        try {
            const result = await this.client.skillsets.get(skillsetName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return generatedSkillsetToPublicSkillset(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new indexer in a search service.
     * @param indexer - The indexer definition to create in a search service.
     * @param options - Additional optional arguments.
     */
    async createIndexer(indexer, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-createIndexer", options);
        try {
            const result = await this.client.indexers.create(publicSearchIndexerToGeneratedSearchIndexer(indexer), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return generatedSearchIndexerToPublicSearchIndexer(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new dataSource in a search service.
     * @param dataSourceConnection - The dataSource definition to create in a search service.
     * @param options - Additional optional arguments.
     */
    async createDataSourceConnection(dataSourceConnection, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-createDataSourceConnection", options);
        try {
            const result = await this.client.dataSources.create(publicDataSourceToGeneratedDataSource(dataSourceConnection), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return generatedDataSourceToPublicDataSource(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new skillset in a search service.
     * @param skillset - The skillset containing one or more skills to create in a search service.
     * @param options - Additional optional arguments.
     */
    async createSkillset(skillset, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-createSkillset", options);
        try {
            const result = await this.client.skillsets.create(publicSkillsetToGeneratedSkillset(skillset), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return generatedSkillsetToPublicSkillset(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new indexer or modifies an existing one.
     * @param indexer - The information describing the indexer to be created/updated.
     * @param options - Additional optional arguments.
     */
    async createOrUpdateIndexer(indexer, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-createOrUpdateIndexer", options);
        try {
            const etag = options.onlyIfUnchanged ? indexer.etag : undefined;
            const result = await this.client.indexers.createOrUpdate(indexer.name, publicSearchIndexerToGeneratedSearchIndexer(indexer), Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
            return generatedSearchIndexerToPublicSearchIndexer(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new datasource or modifies an existing one.
     * @param dataSourceConnection - The information describing the datasource to be created/updated.
     * @param options - Additional optional arguments.
     */
    async createOrUpdateDataSourceConnection(dataSourceConnection, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-createOrUpdateDataSourceConnection", options);
        try {
            const etag = options.onlyIfUnchanged ? dataSourceConnection.etag : undefined;
            const result = await this.client.dataSources.createOrUpdate(dataSourceConnection.name, publicDataSourceToGeneratedDataSource(dataSourceConnection), Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
            return generatedDataSourceToPublicDataSource(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new Skillset or modifies an existing one.
     * @param skillset - The information describing the index to be created.
     * @param options - Additional optional arguments.
     */
    async createOrUpdateSkillset(skillset, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-createOrUpdateSkillset", options);
        try {
            const etag = options.onlyIfUnchanged ? skillset.etag : undefined;
            const result = await this.client.skillsets.createOrUpdate(skillset.name, publicSkillsetToGeneratedSkillset(skillset), Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
            return generatedSkillsetToPublicSkillset(result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes an existing indexer.
     * @param indexer - Indexer/Name of the indexer to delete.
     * @param options - Additional optional arguments.
     */
    async deleteIndexer(indexer, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-deleteIndexer", options);
        try {
            const indexerName = typeof indexer === "string" ? indexer : indexer.name;
            const etag = typeof indexer === "string"
                ? undefined
                : options.onlyIfUnchanged
                    ? indexer.etag
                    : undefined;
            await this.client.indexers.delete(indexerName, Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes an existing datasource.
     * @param dataSource - Datasource/Name of the datasource to delete.
     * @param options - Additional optional arguments.
     */
    async deleteDataSourceConnection(dataSourceConnection, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-deleteDataSourceConnection", options);
        try {
            const dataSourceConnectionName = typeof dataSourceConnection === "string" ? dataSourceConnection : dataSourceConnection.name;
            const etag = typeof dataSourceConnection === "string"
                ? undefined
                : options.onlyIfUnchanged
                    ? dataSourceConnection.etag
                    : undefined;
            await this.client.dataSources.delete(dataSourceConnectionName, Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes an existing Skillset.
     * @param skillset - Skillset/Name of the Skillset to delete.
     * @param options - Additional optional arguments.
     */
    async deleteSkillset(skillset, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-deleteSkillset", options);
        try {
            const skillsetName = typeof skillset === "string" ? skillset : skillset.name;
            const etag = typeof skillset === "string"
                ? undefined
                : options.onlyIfUnchanged
                    ? skillset.etag
                    : undefined;
            await this.client.skillsets.delete(skillsetName, Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns the current status and execution history of an indexer.
     * @param indexerName - The name of the indexer.
     * @param options - Additional optional arguments.
     */
    async getIndexerStatus(indexerName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-getIndexerStatus", options);
        try {
            const result = await this.client.indexers.getStatus(indexerName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            return result;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Resets the change tracking state associated with an indexer.
     * @param indexerName - The name of the indexer to reset.
     * @param options - Additional optional arguments.
     */
    async resetIndexer(indexerName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-resetIndexer", options);
        try {
            await this.client.indexers.reset(indexerName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Runs an indexer on-demand.
     * @param indexerName - The name of the indexer to run.
     * @param options - Additional optional arguments.
     */
    async runIndexer(indexerName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-runIndexer", options);
        try {
            await this.client.indexers.run(indexerName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function formatNullAndUndefined(input) {
    if (input === null || input === undefined) {
        return "null";
    }
    return input;
}
function escapeQuotesIfString(input, previous) {
    let result = input;
    if (typeof input === "string") {
        result = input.replace(/'/g, "''");
        // check if we need to escape this literal
        if (!previous.trim().endsWith("'")) {
            result = `'${result}'`;
        }
    }
    return result;
}
/**
 * Escapes an odata filter expression to avoid errors with quoting string literals.
 * Example usage:
 * ```ts
 * const baseRateMax = 200;
 * const ratingMin = 4;
 * const filter = odata`Rooms/any(room: room/BaseRate lt ${baseRateMax}) and Rating ge ${ratingMin}`;
 * ```
 * For more information on supported syntax see: https://docs.microsoft.com/en-us/azure/search/search-query-odata-filter
 * @param strings - Array of strings for the expression
 * @param values - Array of values for the expression
 */
function odata(strings, ...values) {
    const results = [];
    for (let i = 0; i < strings.length; i++) {
        results.push(strings[i]);
        if (i < values.length) {
            if (values[i] === null || values[i] === undefined) {
                results.push(formatNullAndUndefined(values[i]));
            }
            else {
                results.push(escapeQuotesIfString(values[i], strings[i]));
            }
        }
    }
    return results.join("");
}

// Copyright (c) Microsoft Corporation.
const readFileAsync = util.promisify(fs.readFile);
/**
 * Helper method to create a SynonymMap object. This is a NodeJS only method.
 *
 * @param name - Name of the SynonymMap.
 * @param filePath - Path of the file that contains the Synonyms (seperated by new lines)
 * @returns SynonymMap object
 */
async function createSynonymMapFromFile(name, filePath) {
    const synonyms = (await readFileAsync(filePath, "utf-8")).trim().split(/\s*\r?\n\s*/);
    return {
        name,
        synonyms
    };
}

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () {
        return coreAuth.AzureKeyCredential;
    }
});
exports.DEFAULT_BATCH_SIZE = DEFAULT_BATCH_SIZE;
exports.DEFAULT_FLUSH_WINDOW = DEFAULT_FLUSH_WINDOW;
exports.DEFAULT_RETRY_COUNT = DEFAULT_RETRY_COUNT;
exports.GeographyPoint = GeographyPoint;
exports.IndexDocumentsBatch = IndexDocumentsBatch;
exports.SearchClient = SearchClient$1;
exports.SearchIndexClient = SearchIndexClient;
exports.SearchIndexerClient = SearchIndexerClient;
exports.SearchIndexingBufferedSender = SearchIndexingBufferedSender;
exports.createSynonymMapFromFile = createSynonymMapFromFile;
exports.odata = odata;
//# sourceMappingURL=index.js.map
